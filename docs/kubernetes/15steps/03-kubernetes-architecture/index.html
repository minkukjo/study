<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/study/blog/rss.xml" title="도전하는 개발자 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/study/blog/atom.xml" title="도전하는 개발자 Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="도전하는 개발자" href="/study/opensearch.xml"><title data-react-helmet="true">03. 쿠버네티스의 기본 | 도전하는 개발자</title><meta data-react-helmet="true" property="og:url" content="https://minkukjo.github.io/study/docs/kubernetes/15steps/03-kubernetes-architecture"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="03. 쿠버네티스의 기본 | 도전하는 개발자"><meta data-react-helmet="true" name="description" content="쿠버네티스의 기본적인 아키텍처 이해"><meta data-react-helmet="true" property="og:description" content="쿠버네티스의 기본적인 아키텍처 이해"><link data-react-helmet="true" rel="shortcut icon" href="/study/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://minkukjo.github.io/study/docs/kubernetes/15steps/03-kubernetes-architecture"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/kubernetes/15steps/03-kubernetes-architecture" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/kubernetes/15steps/03-kubernetes-architecture" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://R6WS6DHCQH-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/study/assets/css/styles.2d555e26.css">
<link rel="preload" href="/study/assets/js/runtime~main.05b15718.js" as="script">
<link rel="preload" href="/study/assets/js/main.676c26ab.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/study/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/study/blog">Blog</a><a class="navbar__item navbar__link" href="/study/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/study/docs/intro">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/study/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" href="/study/about">About</a></li><li class="menu__list-item"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/study/docs/intro">소개</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">JPA</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/jpa/kotlin-jpa-guide">Kotlin JPA 개발 가이드</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Kubernetes</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">15단계로 배우는 쿠버네티스</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/00-intro">00. 스터디 시작의 계기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/01-what-is-k8s">01. 쿠버네티스란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/02-what-is-container">02. 컨테이너란 무엇인가</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/study/docs/kubernetes/15steps/03-kubernetes-architecture">03. 쿠버네티스의 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/04-docker-command">04. 도커 명령어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/05-docker-deeper">05. 도커 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/06-dockerfile">06. 컨테이너 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/07-container-network">07. 컨테이너 네트워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/08-container-api">08. 컨테이너 API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/09-kubernetes-first-step">09. 쿠버네티스 첫 걸음</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/10-manifest">10. 매니페스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/11-service">11. 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/12-ingress">12. 인그레스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/13-deplyoment">13. 디플로이먼트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/14-statefulset">14. 스테이트풀셋</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/15-autoscale">15. 오토스케일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/16-ingress-deeper">16. 인그레스 기능</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/17-storage">17. 스토리지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/15steps/18-job">18. Job과 Cron Job</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kubernetes/node-isolation">특정 노드에만 파드 배포하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">이펙티브 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/01-intro">01. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/02-object-create-destroy">02. 객체 생성 파괴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/03-public-method">03. 모든 객체의 공통 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/04-class-interface">04. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/05-generic">05. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/06-enum-annotation">06. 이넘 타입과 애너테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/07-lambda-stream">07. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/08-method">08. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/09-programming-rule">09. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/10-exception">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/11-concurrency">11. 동시성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/12-serialize">12. 직렬화</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/java-language-guide">자바 언어 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kotlin/kotlin-language-guide">코틀린 언어 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kafka</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">카프카 핵심 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/03-consumer">03. 카프카 컨슈머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/05-internal">05. 카프카의 내부 메커니즘</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/07-data-pipeline">07. 데이터 파이프라인 구축하기</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">03. 쿠버네티스의 기본</h1></header><div class="markdown"><blockquote><p>쿠버네티스의 기본적인 아키텍처 이해</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="아키텍처"></a>아키텍처<a class="hash-link" href="#아키텍처" title="Direct link to heading">#</a></h3><img width="1464" alt="k8s node" src="https://user-images.githubusercontent.com/43809168/101613655-5d797380-3a4f-11eb-99fd-52004e8dc0ab.png"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="k8s-클러스터를-구성하는-코어-프로세스"></a>k8s 클러스터를 구성하는 코어 프로세스<a class="hash-link" href="#k8s-클러스터를-구성하는-코어-프로세스" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kubectl"></a>kubectl<a class="hash-link" href="#kubectl" title="Direct link to heading">#</a></h3><p>k8s 클러스터를 조회하기 위한 도구.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kube-apiserver"></a>kube-apiserver<a class="hash-link" href="#kube-apiserver" title="Direct link to heading">#</a></h3><p>kubectl 등의 API 클라이언트로부터 오는 REST 요청을 검증하고, API 오브젝트를 구성하고 상태를 보고한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kube-scheduler"></a>kube-scheduler<a class="hash-link" href="#kube-scheduler" title="Direct link to heading">#</a></h3><p>k8s의 기본 스케쥴러이다.</p><p><strong>새로 생성된 모든 파드에 대해 실행할 최적의 노드를 선택한다.</strong></p><p>스케줄러는 파드가 실행 가능한 노드를 찾은 다음 점수를 계산하여 가장 점수가 높은 노드를 선택한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kube-controller-manager"></a>kube-controller-manager<a class="hash-link" href="#kube-controller-manager" title="Direct link to heading">#</a></h3><p>컨트롤러를 구동하는 마스터상의 컴포넌트</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cloud-controller-manager"></a>cloud-controller-manager<a class="hash-link" href="#cloud-controller-manager" title="Direct link to heading">#</a></h3><p>API를 통해 클라우드 서비스와 연계하는 컨트롤러로, <strong>클라우드 업체에서 개발한다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="etcd"></a>etcd<a class="hash-link" href="#etcd" title="Direct link to heading">#</a></h3><p><strong>k8s 클러스터의 모든 관리 데이터는 etcd에 저장된다.</strong></p><p>이 etcd는 CoreOS가 개발한 분산 키/값 저장소로 신뢰성이 요구되는 핵심 데이터의 저장 및 접근을 위해 설계되었다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kubelet"></a>kubelet<a class="hash-link" href="#kubelet" title="Direct link to heading">#</a></h3><p>kubelet은 각 노드에서 다음과 같은 역할을 수행한다.</p><ul><li><p>파드와 컨테이너의 실행</p></li><li><p>파드와 노드의 상태를 API 서버에 보고</p></li><li><p>컨테이너의 동작을 확인하는 프로브 실행</p></li><li><p>내장된 cAdvisor를 통해 메트릭 수집 및 공개</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kube-proxy"></a>kube-proxy<a class="hash-link" href="#kube-proxy" title="Direct link to heading">#</a></h3><p>kube-proxy는 각 노드에서 동작하며 로드밸런싱 기능을 제공한다.</p><ul><li><p>서비스와 파드의 변경을 감지하여 최신 상태로 유지</p></li><li><p>iptables 규칙을 관리</p></li><li><p>서비스명과 ClusterIP를 내부 DNS에 등록</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="coredns"></a>coredns<a class="hash-link" href="#coredns" title="Direct link to heading">#</a></h3><p>파드가 서비스 이름으로부터 IP 주소를 얻기 위해 사용한다.</p><p>버전 1.11부터 kube-dns 대신 coredns가 사용되었다.</p><p>이전 kube-dns의 부족한 신뢰성,보안성,유연성이 coredns로 개선되었다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="애드온-컴포넌트"></a>애드온 컴포넌트<a class="hash-link" href="#애드온-컴포넌트" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kube-flannel"></a>kube-flannel<a class="hash-link" href="#kube-flannel" title="Direct link to heading">#</a></h3><p>kube-flannel은 모든 노드에서 실행되어 여러 노드 사이에서 IPv4 네트워크를 제공한다.</p><p>이에 따라 컨테이너는 k8s 클러스터 내부에서 사용되는 IP 주소를 바탕으로 다른 노드에 있는 파드와 통신이 가능하다.</p><p>네트워크 접근 제어가 필요하다면 calico를 사용해야한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="calico-kube-controllers"></a>calico-kube-controllers<a class="hash-link" href="#calico-kube-controllers" title="Direct link to heading">#</a></h3><p>calico를 위한 컨트롤러.</p><p>데이터 스토어로서 etcd를 이용하기 위해 사용된다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="calico-node"></a>calico-node<a class="hash-link" href="#calico-node" title="Direct link to heading">#</a></h3><p>모든 노드에서 실행되어 노드 간 파드 통신, 라우팅, 네트워크 접근 관리 기능을 제공한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="kubernetes-dashboard"></a>kubernetes-dashboard<a class="hash-link" href="#kubernetes-dashboard" title="Direct link to heading">#</a></h3><p>Web 대시보드</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="heapster"></a>heapster<a class="hash-link" href="#heapster" title="Direct link to heading">#</a></h3><p>kubelet에 내장된 cAdvisor로부터 매트릭 정보를 수집. 그러나 1.11부터 지원 중단</p><p>(이름처럼 힙하게 사라졌다)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="metrics-server"></a>metrics-server<a class="hash-link" href="#metrics-server" title="Direct link to heading">#</a></h3><p>heapster를 대신하여 1.8부터 도입되었다.</p><p>API의 aggregation layer를 통해 k8s 클러스터 전체로부터 메트릭을 수집한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쿠버네티스-계층-구조"></a>쿠버네티스 계층 구조<a class="hash-link" href="#쿠버네티스-계층-구조" title="Direct link to heading">#</a></h2><img width="747" alt="스크린샷 2020-12-09 오후 6 50 46" src="https://user-images.githubusercontent.com/43809168/101613725-73873400-3a4f-11eb-8321-556ac20fef49.png"><p><a href="https://geekflare.com/kubernetes-architecture/" target="_blank" rel="noopener noreferrer">계층 구조 이미지 출처</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="마스터-노드의-역할"></a>마스터 노드의 역할<a class="hash-link" href="#마스터-노드의-역할" title="Direct link to heading">#</a></h3><ul><li><p>쿠버네티스의 API서버로서 클라이언트로부터의 명령을 받아들여 실행</p></li><li><p>컨테이너를 파드 단위로 스케줄링 및 삭제</p><ul><li>여기서 말하는 스케줄링은 파드를 실행할 노드를 정하는 것을 의미</li></ul></li><li><p>파드의 컨트롤러 기능과 외부 리소스 관리</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쿠버네티스의-api-오브젝트"></a>쿠버네티스의 API 오브젝트<a class="hash-link" href="#쿠버네티스의-api-오브젝트" title="Direct link to heading">#</a></h2><p>쿠버네티스 API 리소스의 개요를 살펴보자.</p><p>쿠버네티스에서 사용되는 API 리소스 타입의 이름은 IT 업계에서 관용적으로 사용해던 용어와 다소 다른 의미로 사용되니 주의하자.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쿠버네티스-api란"></a>쿠버네티스 API란?<a class="hash-link" href="#쿠버네티스-api란" title="Direct link to heading">#</a></h3><p>쿠버네티스의 모든 조작은 API를 통해 이루어진다.</p><p>CLI 인터페이스인 kubectl은 마스터 노드 상의 kube-apiserver에게 쿠버네티스 API 규약에 맞게 기술된 목표 상태 선언서인 YAML 형식 또는 JSON 형식으로 전송하여 오브젝트를 만들고, 바꾸고, 제거한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="오브젝트란"></a>오브젝트란?<a class="hash-link" href="#오브젝트란" title="Direct link to heading">#</a></h3><p>k8s 오브젝트란 k8s 클러스터 내부의 엔터티로서 이후 설명할</p><p><strong>파드</strong>, <strong>컨트롤러</strong>, <strong>서비스</strong> 등의 인스턴스를 의미한다.</p><p>각 오브젝트는 메타데이터에 기술된 이름에 의해 식별되며 오브젝트를 만들 때는 반드시 <strong>이름</strong>을 부여해야한다.</p><p>같은 종류의 오브젝트 이름은 하나의 네임스페이스에서 반드시 유일해야한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="워크로드workload"></a>워크로드(Workload)<a class="hash-link" href="#워크로드workload" title="Direct link to heading">#</a></h3><p>워크로드란 오브젝트의 카테고리를 나타내는 용어로 컨테이너와 파드, 그리고 컨트롤러의 그룹을 의미한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컨테이너container"></a>컨테이너(Container)<a class="hash-link" href="#컨테이너container" title="Direct link to heading">#</a></h3><p>쿠버네티스는 컨테이너만을 독자적으로 실행하는 것이 불가능하며, 반드시 파드 내에서 실행해야한다.</p><p>컨테이너 기동 시 설정할 수 있는 항목은 이미지의 이름, 실행 명령어, 실행 인자, 환경 변수, 볼륨, CPU 사용 시간과 메모리 크기의 요청값 및 상한값 등이 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파드pod"></a>파드(Pod)<a class="hash-link" href="#파드pod" title="Direct link to heading">#</a></h3><p>파드는 컨테이너를 실행하기 위한 오브젝트이다.</p><p>하나의 파드에는 하나 또는 여러개의 컨테이너가 구동할 수 있다.</p><p>이 구조는 마치 완두콩이 콩을 담고 있는 모양과 비슷하다.</p><p>그래서 꼬투리를 의미하는 영어 단어 Pod이 이름이 되었다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컨트롤러controller"></a>컨트롤러(Controller)<a class="hash-link" href="#컨트롤러controller" title="Direct link to heading">#</a></h3><p>컨트롤러는 파드의 실행을 제어하는 오브젝트로, 여러 종류의 컨트롤러가 있어 각 컨트롤러의 기능을 이해하고 목적에 맞게 적절히 구별해 사용해야한다.</p><p>예를 들어, 클라이언트-서버 모델에 적합한 디플로이먼트 컨트롤러는 서버가 돌아가는 파드의 개수가 지정한 숫자보다 적으면 자동으로 지정한 개수가 되도록 파드를 기동시킨다.</p><p>배치를 위한 잡 컨트롤러는 배치 처리가 정상 종료될 때 까지 재실행을 반복한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="설정configuration"></a>설정(Configuration)<a class="hash-link" href="#설정configuration" title="Direct link to heading">#</a></h3><p>컨테이너 내 애플리케이션의 설정값이나 비밀번호 등의 정보를 저장할 수 있는 ConfigMap과 Secret이라는 오브젝트가 있다.</p><p>이들을 통해 네임스페이스에 저장된 정보는 컨테이너 내의 파일이나 환경 변수를 통해 애플리케이션에서 참조할 수 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="서비스service"></a>서비스(Service)<a class="hash-link" href="#서비스service" title="Direct link to heading">#</a></h3><p>k8s의 서비스는 파드와 클라이언트를 연결하는 역할을 수행한다.</p><p>서버 역할의 파드가 클라이언트의 요청을 받을 수 있도록 대표 IP 주소를 취득하여 내부 DNS에 등록한다.</p><p>그리고 대표 IP의 주소로서 요청 트래픽을 지정된 파드들에 부하분산하여 전송하는 역할을 수행한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스토리지storage"></a>스토리지(Storage)<a class="hash-link" href="#스토리지storage" title="Direct link to heading">#</a></h3><p>파드나 컨테이너는 실행 시에만 존재하는 일시적인 존재이므로 중요한 데이터를 저장하기 위한 공간이 필요하다.</p><p>이를 위한 퍼시스턴트 볼륨을 사용하여 전원이 꺼져도 데이터가 유지되는 스토리지 시스템이다.</p><p>다만 복수의 노드에서 접속 가능한 퍼시스턴트 볼륨은 쿠버네티스의 범위에 포함되지 않으므로 외부 스토리지 시스템을 연동해야한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파드의-기본"></a>파드의 기본<a class="hash-link" href="#파드의-기본" title="Direct link to heading">#</a></h2><p>하나의 파드에 속하는 모든 컨테이너는 같은 노드에서 동작한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컨테이너-재사용-촉진을-위한-플랫폼"></a>컨테이너 재사용 촉진을 위한 플랫폼<a class="hash-link" href="#컨테이너-재사용-촉진을-위한-플랫폼" title="Direct link to heading">#</a></h3><p>파드는 하나의 목적을 위해 만들어진 컨테이너를 부품처럼 조합할 수 있도록 설계되었다.</p><ol><li>파드 내부의 컨테이너는 파드의 IP 주소와 포트번호를 공유한다.</li><li>파드 내부 컨테이너들은 localhost로 서로 통신할 수 있다.</li><li>파드 내부 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 서로 통신할 수 있다.</li><li>파드의 내부 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유할 수 있다.</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파드는-일시적-존재"></a>파드는 일시적 존재<a class="hash-link" href="#파드는-일시적-존재" title="Direct link to heading">#</a></h3><p>파드는 일시적인 존재이며 나타났다, 사라지기를 반복한다.</p><p>IP도 고정적이지 않다.</p><p>그래서 파드에 요청을 보내고 싶다면 반드시 <strong>서비스</strong>가 필요로하게 된다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파드는-컨테이너의-실행-상태를-관리"></a>파드는 컨테이너의 실행 상태를 관리<a class="hash-link" href="#파드는-컨테이너의-실행-상태를-관리" title="Direct link to heading">#</a></h3><p>파드는 활성 프로브와 준비 상태 프로브를 설정하여 내부 애플리케이션의 사앹를 감시할 수 있다.</p><p>활성 프로브를 설정하면 애플리케이션이 멈춰있는 상태를 감지하여 컨테이너를 강제 종료 시킬 수 있고,</p><p>준비 상태 프로브를 설정하면 파드가 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않는다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파드의-라이프-사이클"></a>파드의 라이프 사이클<a class="hash-link" href="#파드의-라이프-사이클" title="Direct link to heading">#</a></h2><p>k8s의 트러블 슈팅 중 가장 많이 발생하는 것이 바로 파드의 기동 실패 원인 분석이다.</p><p>이 문제를 파악하기 위해서는 <code>kubectl get pods</code>를 실행했을 때 나타나는 <strong>STATUS</strong> 열의 정보가 중요하다.</p><p>이 필드의 정보는 k8s API를 통해 획득하는데, 이 API를 통해 얻을 수 있는 여러 정보 중 도움이 될 만한 정보가 선별되어 STATUS 열에 표현되기 때문이다.</p><p>기본적으로 익히 잘 알고 있는 <code>Pending(파드 생성 요구를 받았지만 생성이 덜 된 상태)</code>, <code>Running(정상 구동 중)</code>, <code>Succeded(정상 종료 완료)</code>, <code>Failed(파드 내에 적어도 하나 이상의 컨테이너 종료)</code>, <code>Unknown(파드 상태 불명)</code> 외에 저자가 실험해서 얻은 결과를 살펴보자.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="containercreating"></a>ContainerCreating<a class="hash-link" href="#containercreating" title="Direct link to heading">#</a></h3><p>이미지를 다운로드 중이거나 컨테이너를 생성하는 중</p><p>컨피그맵과 시크릿이 마운트되지 않아 컨테이너 생성이 보류되는 경우일 수 있음</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="crashloopbackoff"></a>CrashLoopBackOff<a class="hash-link" href="#crashloopbackoff" title="Direct link to heading">#</a></h3><p>굉장히 빈번하게 발생하는 상태 중 하나이다.</p><p>파드 내의 컨테이너가 종료되어 다음 기동 시 까지 대기 상태에 있음을 의미한다.</p><p>2회 이상 컨테이너가 종료되면 CrashLoopBackOff 시간 동안 대기하게 된다.</p><p>이 경우 컨테이너 내의 프로세스를 검토할 필요가 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="terminating"></a>Terminating<a class="hash-link" href="#terminating" title="Direct link to heading">#</a></h3><p>컨테이너에 종료 요청 시그널을 보낸 후 컨테이너가 종료할 때까지 대기 중임을 의미.</p><p>유예 시간을 넘겨도 컨테이너가 종료할 수 없는 경우 컨테이너를 강제 종료한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="completed"></a>Completed<a class="hash-link" href="#completed" title="Direct link to heading">#</a></h3><p>파드 내 컨테이너 정상 종료.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="error"></a>Error<a class="hash-link" href="#error" title="Direct link to heading">#</a></h3><p>컨테이너가 이상 종료된 경우.</p><p>Exit 코드가 0이 아닌 경우 발생한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파드의-종료-처리"></a>파드의 종료 처리<a class="hash-link" href="#파드의-종료-처리" title="Direct link to heading">#</a></h3><p>k8s는 종료 요청 시그널을 받은 컨테이너의 애플리케이션이 일정 시간 내에 종료 처리를 완료하고 정상 종료되도록 요구하고 있다.</p><p>이 종료처리의 흐름은 아래와 같다.</p><ol><li><p>사용자가 kubectl delete pod을 실행하면 파드가 종료되기 시작한다. 기본 유예 시간은 30초다</p></li><li><p>kubectl get pod의 status는 Terminating이 표시된다.</p></li><li><p>다음 세 가지 작업이 동시에 진행된다.</p><ul><li>파드의 PreStop hook이 정의되어있다면 파드 내에서 호출된다. 유예 시간을 넘으면 PreStop hook이 실행되더라도 파드 내의 메인 프로세스에 SIGTERM이 보내지며, 2초 후에 SIGKILL로 강제 종료된다.</li><li>PreStop hook이 정의되어있지않다면 곧바로 파드 내의 메인 프로세스에 SIGTERM 신호가 송된되며 종료 처리가 개시된다.</li><li>파드가 서비스의 엔드포인트 목록에서 제거되며 로드 밸런서의 목록에서도 제거된다.</li></ul></li><li><p>유예 시간을 넘어서서 파드 내의 프로세스가 살아 있다면 파드의 메인 프로세스에 SIGKILL을 보내서 강제로 종료한다.</p></li><li><p>제거 대상인 파드가 표시되지 않게 한다.</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="클러스터-네트워크"></a>클러스터 네트워크<a class="hash-link" href="#클러스터-네트워크" title="Direct link to heading">#</a></h2><p>k8s 클러스터 내부에서 사용되는 클러스터 네트워크에 대해 알아보자.</p><p>파드는 이 네트워크 상의 IP 주소를 부여받아 다른 노드에 있는 파드와 서로 통신한다.</p><p>파드 네트워크는 각 개발사의 특징을 살릴 수 있게 구현되어있는데 우리는 여기서 2개의 대표적인 오픈 소스 네트워크 에드온을 살펴보자.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="flannel"></a>Flannel<a class="hash-link" href="#flannel" title="Direct link to heading">#</a></h3><p>간단한 L3 네트워크를 노드 간에 구축한다.</p><p>Flannel 파드는 데몬셋 컨트롤러에 의해 배포된다. 때문에 클러스터에 새로운 노드가 추가되면 자동적으로 파드 네트워크가 확장된다.</p><p>Flannel은 단순 네트워크 기능만 지원하며 ACL 기능은 지원하지 않는다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="calico"></a>Calico<a class="hash-link" href="#calico" title="Direct link to heading">#</a></h3><p>노드 간 파드 통신에 더해 ACL 기능을 제공한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="서비스의-기본"></a>서비스의 기본<a class="hash-link" href="#서비스의-기본" title="Direct link to heading">#</a></h2><p>서비스의 필요성은 파드가 기동할 때 마다 IP 주소가 계속해서 바뀌기 떄문이다.</p><p>파드에 접속해야하는 클라이언트는 서비스가 가지는 대표 IP를 사용해 접속해야한다.</p><p>서비스의 역할에 대해서 조금 더 자세히 알아보자.</p><ol><li><p>서비스는 로드밸런서의 역할을 가지며 대표 IP 주소를 획득한다.</p></li><li><p>서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 서비스의 이름만으로 서비스의 IP 주소를 획득할 수 있다.</p></li><li><p>서비스는 셀렉터에 저장된 라벨과 일치하는 파드 중 하나에게 요청을 전송한다.</p></li><li><p>서비스가 만들어지고 나서 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경 변수가 자동으로 설정된다.</p></li><li><p>서비스에는 네 종류의 서비스 타입이 있어 클라이언트의 범위를 k8s 클러스터 내부로 한정할지, 외부까지 확장할지, 또한 k8s 클러스터 외부의 IP 주소에 전송할지를 설정한다.</p></li></ol><p>3번에 대한 조금 더 자세한 내용은 다음과 같다.</p><p>파드는 기동될 때 라벨이나 IP 주소를 포함한 자신의 오브젝트 정보를 마스터 노드의 etcd에 등록한다.</p><p>그래서 서비스의 전송처를 결정할 때 셀렉테(selector)의 라벨에 일치하는 파드를 etcd에서 조회하여 전송할 파드의 IP 주소를 취득한다.</p><p>이처럼 라벨에 의해 대상 오브젝트를 결정하는 것이 k8s의 기본 동작이다.</p><p>서비스의 기능을 이해할 때 중요한 7개의 키워드는 다음과 같다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="대표-ip-주소"></a>대표 IP 주소<a class="hash-link" href="#대표-ip-주소" title="Direct link to heading">#</a></h3><p>서비스는 파드의 그룹을 대표해 클라이언트의 요청을 받을 대표 IP 주소를 가진다.</p><p>헤드리스로 지정한 경우에는 대표 IP 주소를 획득하지 않고, 파드의 IP 주소를 직접 내부 DNS에 설정한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="부하분산"></a>부하분산<a class="hash-link" href="#부하분산" title="Direct link to heading">#</a></h3><p>서비스의 대표 IP 주소에 도착한 요청은 셀렉터의 라벨과 일치하는 파드에 전송된다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="이름-해결"></a>이름 해결<a class="hash-link" href="#이름-해결" title="Direct link to heading">#</a></h3><p>서비스는 IP 주소와 서비스명을 k8s 클러스터 내부의 DNS에 등록한다.</p><p>그래서 클러스터 내의 파드에서는 서비스 이름으로 파드에 접근하는 것이 가능하다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="환경-변수"></a>환경 변수<a class="hash-link" href="#환경-변수" title="Direct link to heading">#</a></h3><p>서비스가 만들어지나고 나서 생성되는 파드의 컨테이너에는 환경 변수가 설정되어있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="서비스-타입"></a>서비스 타입<a class="hash-link" href="#서비스-타입" title="Direct link to heading">#</a></h3><p>서비스를 설정할 때는 해당 서비스를 이용하는 클라이언트를 고려하여 서비스 타입을 지정할 수 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="어피니티"></a>어피니티<a class="hash-link" href="#어피니티" title="Direct link to heading">#</a></h3><p>기본적으로 부하분산에 사용되는 알고리즘은 <strong>랜덤</strong>이다.</p><p>클라이언트에 따라 전송되는 파드를 고정시키고 싶다면 <strong>sessionAffinity</strong> 항목에 <strong>ClientIP</strong>를 설정한다.</p><p>HTTP 헤더안의 쿠키 값에 따라 전송되는 파드를 고정시키고 싶다면 인그레스를 이용해야한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="셀렉터와-라벨"></a>셀렉터와 라벨<a class="hash-link" href="#셀렉터와-라벨" title="Direct link to heading">#</a></h3><p>서비스에 도달한 요청 트래픽이 파드에 전송될 때 셀렉터와 라벨을 참조한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컨트롤러의-기본"></a>컨트롤러의 기본<a class="hash-link" href="#컨트롤러의-기본" title="Direct link to heading">#</a></h2><p>컨트롤러는 파드를 제어한다.</p><p>파드에게 부여할 워크로드의 타입, 처리에 따라 적절한 컨트롤러를 설정해야한다.</p><p>이 세션에서는 워크로드와 컨트롤러의 특징을 살펴보자.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="워크로드-타입"></a>워크로드 타입<a class="hash-link" href="#워크로드-타입" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="프론트엔드-처리"></a>프론트엔드 처리<a class="hash-link" href="#프론트엔드-처리" title="Direct link to heading">#</a></h3><p>스마트폰, IoT, 컴퓨터 등 클라이언트로부터 요청을 받아들이는 워크로드를 총칭한다.</p><p>이 타입의 워크로드는 대량의 클라이언트 요청에 대해 짧은 시간에 응답을 반환해주는 것이 중요하다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="백엔드-처리"></a>백엔드 처리<a class="hash-link" href="#백엔드-처리" title="Direct link to heading">#</a></h3><p>백엔드는 요쳥량이 변하더라도 일정한 응답속도를 유지해주어야한다.</p><p>또한 요구사항에 맞게 단 기간에 기능을 추가하고 변경하는 것이 가능해야한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="배치-처리"></a>배치 처리<a class="hash-link" href="#배치-처리" title="Direct link to heading">#</a></h3><p>배치 처리는 어떤 트리거에 의해 실행되며 대용량 데이터 전송에 주로 사용된다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="시스템-운영-처리"></a>시스템 운영 처리<a class="hash-link" href="#시스템-운영-처리" title="Direct link to heading">#</a></h3><p>시스템 운영을 돕기 위해 k8s API를 사용하기도 한다.</p><p><strong>구글</strong>이 강조하는 SRE는 소프트웨어 기술자가 시스템 운영의 자동화에 집중하여 효율적인 시스템 운영을 실현한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컨트롤러-타입"></a>컨트롤러 타입<a class="hash-link" href="#컨트롤러-타입" title="Direct link to heading">#</a></h2><p>컨트롤러는 앞서 살펴본 워크로드를 처리하기 위해 파드를 제어하고 실행하는 역할을 담당한다.</p><p>대표적인 컨트롤러 7개의 역할과 특징은 다음과 같다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="디플로이먼트deployment"></a>디플로이먼트(Deployment)<a class="hash-link" href="#디플로이먼트deployment" title="Direct link to heading">#</a></h3><p>대등한 관계에 있는 여러 개의 파드로 수평한 클러스터를 구성할 때 사용한다.</p><p>가동중인 파드를 차례대로 교체하거나 규모를 조절할 수 있는 기능을 갖추고 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스테이트풀셋statefulset"></a>스테이트풀셋(StatefulSet)<a class="hash-link" href="#스테이트풀셋statefulset" title="Direct link to heading">#</a></h3><p>파드와 퍼시스턴트 볼륨을 조합하여 데이터의 보관에 초점을 둔 컨트롤러이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="잡job"></a>잡(Job)<a class="hash-link" href="#잡job" title="Direct link to heading">#</a></h3><p>배치 처리를 하는 컨테이너가 정상 종료할 때까지 재실행을 반복하는 컨트롤러이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="크론잡cronjob"></a>크론잡(CronJob)<a class="hash-link" href="#크론잡cronjob" title="Direct link to heading">#</a></h3><p>정해진 시간에 정기적으로 앞서 설명한 잡을 생성한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데몬셋daemonset"></a>데몬셋(DaemonSet)<a class="hash-link" href="#데몬셋daemonset" title="Direct link to heading">#</a></h3><p>k8s 클러스터의 모든 노드에서 같은 파드를 실행하기 위해 존재한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="레플리카셋replicaset"></a>레플리카셋(ReplicaSet)<a class="hash-link" href="#레플리카셋replicaset" title="Direct link to heading">#</a></h3><p>디플로이먼트 컨트롤러와 연동해 파드가 기동해야하는 수를 관리한다.</p><p>레플리카셋은 직접 다루기보다는 디플로이먼트를 통해 이용하는 것이 기본이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="레플리케이션-컨트롤러replication-controller"></a>레플리케이션 컨트롤러(Replication Controller)<a class="hash-link" href="#레플리케이션-컨트롤러replication-controller" title="Direct link to heading">#</a></h3><p>(구) 디플로이먼트 지금은 안쓴다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="노드의-스케일업과-관련하여"></a>노드의 스케일업과 관련하여<a class="hash-link" href="#노드의-스케일업과-관련하여" title="Direct link to heading">#</a></h2><p>CPU 코어수를 늘리거나 메모리 증설 등 노드의 스케일업과 관련된 기능은 컨트롤러에서 담당하지않는다.</p><p>이러한 노드 스케일 업은 클라우드의 경우 보다 많은 CPU 코어 수나 메모리 용량을 탑재한 노드를 준비해서 k8s에 추가 후, 파드의 노드 셀렉터를 설정해 마이그레이션해야한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핵심요약"></a>핵심요약<a class="hash-link" href="#핵심요약" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-k8s-클러스터는-마스터와-노드로-구성된다"></a>1) k8s 클러스터는 마스터와 노드로 구성된다<a class="hash-link" href="#1-k8s-클러스터는-마스터와-노드로-구성된다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-cncf가-배포하는-k8s가-기본이며-클라우드-업체나-솔루션-업체들이-자사-제품을-위해-독자적으로-기능을-추가하거나-확장하기도-한다"></a>2) CNCF가 배포하는 k8s가 기본이며 클라우드 업체나 솔루션 업체들이 자사 제품을 위해 독자적으로 기능을 추가하거나 확장하기도 한다<a class="hash-link" href="#2-cncf가-배포하는-k8s가-기본이며-클라우드-업체나-솔루션-업체들이-자사-제품을-위해-독자적으로-기능을-추가하거나-확장하기도-한다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-마스터는-목표-상태가-기술된-매니페스트를-받아들여서-그-상태가-유지되도록-오브젝트를-제어한다"></a>3) 마스터는 목표 상태가 기술된 매니페스트를 받아들여서 그 상태가 유지되도록 오브젝트를 제어한다<a class="hash-link" href="#3-마스터는-목표-상태가-기술된-매니페스트를-받아들여서-그-상태가-유지되도록-오브젝트를-제어한다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-k8s-클러스터의-모든-조작은-쿠버네티스-api에-의해-실행되며-오브젝트-작성-수정-삭제-상태-조회-등을-실행한다"></a>4) k8s 클러스터의 모든 조작은 쿠버네티스 API에 의해 실행되며 오브젝트 작성, 수정, 삭제, 상태 조회 등을 실행한다<a class="hash-link" href="#4-k8s-클러스터의-모든-조작은-쿠버네티스-api에-의해-실행되며-오브젝트-작성-수정-삭제-상태-조회-등을-실행한다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5-주요-오브젝트로는-파드-서비스-컨트롤러-세-가지가-있다"></a>5) 주요 오브젝트로는 파드, 서비스, 컨트롤러 세 가지가 있다<a class="hash-link" href="#5-주요-오브젝트로는-파드-서비스-컨트롤러-세-가지가-있다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="6-파드는-컨테이너의-기동-단위이며-서비스와-컨트롤러와-함께-사용된다"></a>6) 파드는 컨테이너의 기동 단위이며 서비스와 컨트롤러와 함께 사용된다<a class="hash-link" href="#6-파드는-컨테이너의-기동-단위이며-서비스와-컨트롤러와-함께-사용된다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="7-컨테이너-내-프로그램의-시그널-처리는-데이터-손실을-막고-안전하게-종료하도록-구현되어야한다"></a>7) 컨테이너 내 프로그램의 시그널 처리는 데이터 손실을 막고 안전하게 종료하도록 구현되어야한다<a class="hash-link" href="#7-컨테이너-내-프로그램의-시그널-처리는-데이터-손실을-막고-안전하게-종료하도록-구현되어야한다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="8-서비스는-클라이언트로부터의-요청을-지정한-파드에-부하분산하며-전송하는-역할을-담당한다"></a>8) 서비스는 클라이언트로부터의 요청을 지정한 파드에 부하분산하며 전송하는 역할을 담당한다<a class="hash-link" href="#8-서비스는-클라이언트로부터의-요청을-지정한-파드에-부하분산하며-전송하는-역할을-담당한다" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="9-워크로드의-특성에-맞게-컨트롤러를-선택해서-쿠버네티스를-사용해야한다"></a>9) 워크로드의 특성에 맞게 컨트롤러를 선택해서 쿠버네티스를 사용해야한다<a class="hash-link" href="#9-워크로드의-특성에-맞게-컨트롤러를-선택해서-쿠버네티스를-사용해야한다" title="Direct link to heading">#</a></h4><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reference"></a>Reference<a class="hash-link" href="#reference" title="Direct link to heading">#</a></h2><p><img src="https://user-images.githubusercontent.com/43809168/101032998-6684c380-35bd-11eb-8ba7-a784fd46b37a.png" alt="k8s"></p><p>15단계로 배우는 도커와 쿠버네티스 - 타카라 마호 저서</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/minkukjo/study/edit/master/docs/kubernetes/15steps/03-kubernetes-architecture.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-05-29T03:52:54.000Z" class="lastUpdatedDate_1WI_">5/29/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/study/docs/kubernetes/15steps/02-what-is-container"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 02. 컨테이너란 무엇인가</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/study/docs/kubernetes/15steps/04-docker-command"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">04. 도커 명령어 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#아키텍처" class="table-of-contents__link">아키텍처</a></li><li><a href="#k8s-클러스터를-구성하는-코어-프로세스" class="table-of-contents__link">k8s 클러스터를 구성하는 코어 프로세스</a><ul><li><a href="#kubectl" class="table-of-contents__link">kubectl</a></li><li><a href="#kube-apiserver" class="table-of-contents__link">kube-apiserver</a></li><li><a href="#kube-scheduler" class="table-of-contents__link">kube-scheduler</a></li><li><a href="#kube-controller-manager" class="table-of-contents__link">kube-controller-manager</a></li><li><a href="#cloud-controller-manager" class="table-of-contents__link">cloud-controller-manager</a></li><li><a href="#etcd" class="table-of-contents__link">etcd</a></li><li><a href="#kubelet" class="table-of-contents__link">kubelet</a></li><li><a href="#kube-proxy" class="table-of-contents__link">kube-proxy</a></li><li><a href="#coredns" class="table-of-contents__link">coredns</a></li></ul></li><li><a href="#애드온-컴포넌트" class="table-of-contents__link">애드온 컴포넌트</a><ul><li><a href="#kube-flannel" class="table-of-contents__link">kube-flannel</a></li><li><a href="#calico-kube-controllers" class="table-of-contents__link">calico-kube-controllers</a></li><li><a href="#calico-node" class="table-of-contents__link">calico-node</a></li><li><a href="#kubernetes-dashboard" class="table-of-contents__link">kubernetes-dashboard</a></li><li><a href="#heapster" class="table-of-contents__link">heapster</a></li><li><a href="#metrics-server" class="table-of-contents__link">metrics-server</a></li></ul></li><li><a href="#쿠버네티스-계층-구조" class="table-of-contents__link">쿠버네티스 계층 구조</a><ul><li><a href="#마스터-노드의-역할" class="table-of-contents__link">마스터 노드의 역할</a></li></ul></li><li><a href="#쿠버네티스의-api-오브젝트" class="table-of-contents__link">쿠버네티스의 API 오브젝트</a><ul><li><a href="#쿠버네티스-api란" class="table-of-contents__link">쿠버네티스 API란?</a></li><li><a href="#오브젝트란" class="table-of-contents__link">오브젝트란?</a></li><li><a href="#워크로드workload" class="table-of-contents__link">워크로드(Workload)</a></li><li><a href="#컨테이너container" class="table-of-contents__link">컨테이너(Container)</a></li><li><a href="#파드pod" class="table-of-contents__link">파드(Pod)</a></li><li><a href="#컨트롤러controller" class="table-of-contents__link">컨트롤러(Controller)</a></li><li><a href="#설정configuration" class="table-of-contents__link">설정(Configuration)</a></li><li><a href="#서비스service" class="table-of-contents__link">서비스(Service)</a></li><li><a href="#스토리지storage" class="table-of-contents__link">스토리지(Storage)</a></li></ul></li><li><a href="#파드의-기본" class="table-of-contents__link">파드의 기본</a><ul><li><a href="#컨테이너-재사용-촉진을-위한-플랫폼" class="table-of-contents__link">컨테이너 재사용 촉진을 위한 플랫폼</a></li><li><a href="#파드는-일시적-존재" class="table-of-contents__link">파드는 일시적 존재</a></li><li><a href="#파드는-컨테이너의-실행-상태를-관리" class="table-of-contents__link">파드는 컨테이너의 실행 상태를 관리</a></li></ul></li><li><a href="#파드의-라이프-사이클" class="table-of-contents__link">파드의 라이프 사이클</a><ul><li><a href="#containercreating" class="table-of-contents__link">ContainerCreating</a></li><li><a href="#crashloopbackoff" class="table-of-contents__link">CrashLoopBackOff</a></li><li><a href="#terminating" class="table-of-contents__link">Terminating</a></li><li><a href="#completed" class="table-of-contents__link">Completed</a></li><li><a href="#error" class="table-of-contents__link">Error</a></li><li><a href="#파드의-종료-처리" class="table-of-contents__link">파드의 종료 처리</a></li></ul></li><li><a href="#클러스터-네트워크" class="table-of-contents__link">클러스터 네트워크</a><ul><li><a href="#flannel" class="table-of-contents__link">Flannel</a></li><li><a href="#calico" class="table-of-contents__link">Calico</a></li></ul></li><li><a href="#서비스의-기본" class="table-of-contents__link">서비스의 기본</a><ul><li><a href="#대표-ip-주소" class="table-of-contents__link">대표 IP 주소</a></li><li><a href="#부하분산" class="table-of-contents__link">부하분산</a></li><li><a href="#이름-해결" class="table-of-contents__link">이름 해결</a></li><li><a href="#환경-변수" class="table-of-contents__link">환경 변수</a></li><li><a href="#서비스-타입" class="table-of-contents__link">서비스 타입</a></li><li><a href="#어피니티" class="table-of-contents__link">어피니티</a></li><li><a href="#셀렉터와-라벨" class="table-of-contents__link">셀렉터와 라벨</a></li></ul></li><li><a href="#컨트롤러의-기본" class="table-of-contents__link">컨트롤러의 기본</a></li><li><a href="#워크로드-타입" class="table-of-contents__link">워크로드 타입</a><ul><li><a href="#프론트엔드-처리" class="table-of-contents__link">프론트엔드 처리</a></li><li><a href="#백엔드-처리" class="table-of-contents__link">백엔드 처리</a></li><li><a href="#배치-처리" class="table-of-contents__link">배치 처리</a></li><li><a href="#시스템-운영-처리" class="table-of-contents__link">시스템 운영 처리</a></li></ul></li><li><a href="#컨트롤러-타입" class="table-of-contents__link">컨트롤러 타입</a><ul><li><a href="#디플로이먼트deployment" class="table-of-contents__link">디플로이먼트(Deployment)</a></li><li><a href="#스테이트풀셋statefulset" class="table-of-contents__link">스테이트풀셋(StatefulSet)</a></li><li><a href="#잡job" class="table-of-contents__link">잡(Job)</a></li><li><a href="#크론잡cronjob" class="table-of-contents__link">크론잡(CronJob)</a></li><li><a href="#데몬셋daemonset" class="table-of-contents__link">데몬셋(DaemonSet)</a></li><li><a href="#레플리카셋replicaset" class="table-of-contents__link">레플리카셋(ReplicaSet)</a></li><li><a href="#레플리케이션-컨트롤러replication-controller" class="table-of-contents__link">레플리케이션 컨트롤러(Replication Controller)</a></li></ul></li><li><a href="#노드의-스케일업과-관련하여" class="table-of-contents__link">노드의 스케일업과 관련하여</a><ul><li><a href="#핵심요약" class="table-of-contents__link">핵심요약</a></li></ul></li><li><a href="#reference" class="table-of-contents__link">Reference</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Harry's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/study/assets/js/runtime~main.05b15718.js"></script>
<script src="/study/assets/js/main.676c26ab.js"></script>
</body>
</html>