<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/study/blog/rss.xml" title="도전하는 개발자 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/study/blog/atom.xml" title="도전하는 개발자 Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="도전하는 개발자" href="/study/opensearch.xml"><title data-react-helmet="true">03. 모든 객체의 공통 메서드 | 도전하는 개발자</title><meta data-react-helmet="true" property="og:url" content="https://minkukjo.github.io/study/docs/java/effective-java/03-public-method"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="03. 모든 객체의 공통 메서드 | 도전하는 개발자"><meta data-react-helmet="true" name="description" content="Object는 자바에서 모든 오브젝트의 최상위 클래스이며 상속을 통해서 사용하도록 설계되었다."><meta data-react-helmet="true" property="og:description" content="Object는 자바에서 모든 오브젝트의 최상위 클래스이며 상속을 통해서 사용하도록 설계되었다."><link data-react-helmet="true" rel="shortcut icon" href="/study/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://minkukjo.github.io/study/docs/java/effective-java/03-public-method"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/java/effective-java/03-public-method" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/java/effective-java/03-public-method" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://R6WS6DHCQH-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/study/assets/css/styles.2d555e26.css">
<link rel="preload" href="/study/assets/js/runtime~main.fcc2c37a.js" as="script">
<link rel="preload" href="/study/assets/js/main.53ddd09a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/study/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/study/blog">Blog</a><a class="navbar__item navbar__link" href="/study/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/study/docs/intro">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/study/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" href="/study/about">About</a></li><li class="menu__list-item"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/study/docs/intro">소개</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">JPA</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/jpa/kotlin-jpa-guide">Kotlin JPA 개발 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Security</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/security/spring-security-resource-server">Spring Security Resource Server</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/security/spring-security-flow">Spring Security OAuth2 Login</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Javascript</a><ul class="menu__list"></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kubernetes</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">15단계로 배우는 쿠버네티스</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/00-intro">00. 스터디 시작의 계기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/01-what-is-k8s">01. 쿠버네티스란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/02-what-is-container">02. 컨테이너란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/03-kubernetes-architecture">03. 쿠버네티스의 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/04-docker-command">04. 도커 명령어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/05-docker-deeper">05. 도커 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/06-dockerfile">06. 컨테이너 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/07-container-network">07. 컨테이너 네트워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/08-container-api">08. 컨테이너 API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/09-kubernetes-first-step">09. 쿠버네티스 첫 걸음</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/10-manifest">10. 매니페스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/11-service">11. 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/12-ingress">12. 인그레스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/13-deplyoment">13. 디플로이먼트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/14-statefulset">14. 스테이트풀셋</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/15-autoscale">15. 오토스케일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/16-ingress-deeper">16. 인그레스 기능</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/17-storage">17. 스토리지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/18-job">18. Job과 Cron Job</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/node-isolation">특정 노드에만 파드 배포하기</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">이펙티브 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/01-intro">01. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/02-object-create-destroy">02. 객체 생성 파괴</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/study/docs/java/effective-java/03-public-method">03. 모든 객체의 공통 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/04-class-interface">04. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/05-generic">05. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/06-enum-annotation">06. 이넘 타입과 애너테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/07-lambda-stream">07. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/08-method">08. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/09-programming-rule">09. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/10-exception">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/11-concurrency">11. 동시성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/12-serialize">12. 직렬화</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/java-language-guide">자바 언어 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kotlin/kotlin-language-guide">코틀린 언어 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kafka</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">카프카 핵심 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/03-consumer">03. 카프카 컨슈머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/05-internal">05. 카프카의 내부 메커니즘</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/07-data-pipeline">07. 데이터 파이프라인 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/11-streams">11. 스트림 프로세싱</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">03. 모든 객체의 공통 메서드</h1></header><div class="markdown"><blockquote><p><code>Object</code>는 자바에서 모든 오브젝트의 최상위 클래스이며 <strong>상속</strong>을 통해서 사용하도록 설계되었다.</p></blockquote><blockquote><p><code>Object</code> 클래스에서 final이 아닌 메서드들 equals, hashCode, toString, clone, finalize 모두 오버라이딩을 염두에 두고 설계된 것이기 때문이다.</p></blockquote><blockquote><p>이번 장에서는 final아 아닌 메서드들을 언제, 어떻게 재정의를 해야하는지에 대해서 살펴보자.</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="eqauls는-일반-규약을-지켜-재정의하라"></a>eqauls는 일반 규약을 지켜 재정의하라<a class="hash-link" href="#eqauls는-일반-규약을-지켜-재정의하라" title="Direct link to heading">#</a></h2><blockquote><p>item 10</p></blockquote><p>결론부터 이야기하자면, equals 메소드는 가급적 재정의하지 않는 편이 좋다.</p><p>개인적인 의견이지만, <code>lombok</code> 라이브러리에서 <code>@EqualsAndHashCode</code>를 지원하는 마당에, 이 아이템이 어떤 의미를 갖는지에 대해서 의문이 들었다.</p><p><strong>equals</strong> 메서드를 재정의하는데에 있어 동치관계를 구현해줘야한다.</p><ol><li><p><strong>반사성</strong>(reflexivity) : null이 아닌 모든 참조값에 x에 대해 x.equals(x)는 true다.</p></li><li><p><strong>대칭성</strong>(symmetry) : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true이다.</p></li><li><p><strong>추이성</strong>(transitivity) : null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true면 y.equals(x)도 true이면 x.equals(z)도 true이다.</p></li><li><p><strong>일관성</strong>(consistency) : null이 아닌 모든 참조 값 x,y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</p></li><li><p><strong>null-아님</strong> : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 true이다.</p></li></ol><p>이후에 나오는 대부분의 예제는 Equals 메서드를 재정의하면서 발생할 수 있는 LCP(리스코프 치환 원칙) 위배 예제와 상속 대신 컴포지션을 사용하라는 식의 <strong>객체지향</strong>관련 이야기가 주를 이룬다.</p><p>(<code>Point</code> 클래스와 이를 상속받은 클래스 간의 종속성 문제를 이야기한다)</p><p><code>equals</code>를 재정의하면서 주의해야할 또 다른 점은 <code>hashCode</code> 메소드도 반드시 재정의를 해주어야한다는 점인데, 이는 다음 아이템에서 소개할 예정이다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="equals를-재정의하려거든-hashcode도-재정의하라"></a>equals를 재정의하려거든 hashCode도 재정의하라<a class="hash-link" href="#equals를-재정의하려거든-hashcode도-재정의하라" title="Direct link to heading">#</a></h2><blockquote><p>item 11</p></blockquote><p><strong>equals를 재정의한 클래스라면 모두 hashCode 또한 재정의해야 한다.</strong></p><p>그렇지않으면 해당 클래스의 인스턴스를 <strong>HashMap</strong>이나 <strong>HashSet</strong>같은 컬렉션의 원소로 사용할 때 문제를 일으킬 수 있다.</p><p><strong>hashCode</strong>를 잘못 재정의헀을 때 크게 나타날 수 있는 문제는 <strong>논리적으로 같은 객체는 같은 해시코드를 반환해야한다</strong>
는 점이다.</p><p>이 역시도 <code>lombok</code> 라이브러리를 사용하거나 Kotlin의 <code>data</code> 클래스를 사용하면 손쉽게 <code>Equals</code>와 <code>HashCode</code> 메서드를 알아서 재정의해준다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tostring을-항상-재정의하라"></a>toString을 항상 재정의하라<a class="hash-link" href="#tostring을-항상-재정의하라" title="Direct link to heading">#</a></h2><blockquote><p>item 12</p></blockquote><p>자바에서 프레임워크를 쓰다보면 종종 <code>toString()</code> 메소드로 인해 고통받는 일이 생긴다.</p><p>이번 시간에는 Object의 메서드 중 하나인 <code>toString()</code>에 대해서 알아보자.</p><p>Object 클래스의 기본 toString 메서드는 꽤나 불친절하다.</p><p>가령 <code>PhoneNumber</code> 클래스의 toString을 호출해보면 <code>Phonenumber@abbdd</code>와 같은 출력 결과를 확인해볼 수 있다.</p><p>toString()은 인간이 읽기 편한 형태가 되어야하므로, 우리는 이 toString()를 재정의해볼 것이다.</p><p>toString() 메서드는 우리가 직접 호출하지않더라도, <code>println</code>이나 <code>assert</code> 구문에 넘길 때, 혹은 디버거가 객체를 출력할 때 자동으로 호출되는 메소드이다.</p><p>즉, 우리가 명시적으로 호출하지않더라도 어딘가에서는 쓰일 수 있다는 이야기이다.</p><p>toString을 똑바로 정의했다면 아래와 같은 코드는 그 의미를 명확히 파악할 수 있게 될 것이다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(phonNumber + &quot;에 연결할 수 없습니다.&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>즉, toString을 사용한다면 <strong>가급적 해당 객체가 갖고 있는 모든 정보들을 노출시켜주는 편이 좋다.</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="clone-재정의는-주의해서-진행하라"></a>clone 재정의는 주의해서 진행하라<a class="hash-link" href="#clone-재정의는-주의해서-진행하라" title="Direct link to heading">#</a></h2><blockquote><p>item 13</p></blockquote><p><code>Clonable</code> 인터페이스는 복제가능한 클래스임을 명시하는 인터페이스임에도, 그 목적을 이루지 못했다.</p><p><code>clone</code> 메서드가 정의된 클래스는 <code>Object</code> 클래스이며 그 마저도 <code>protected</code> 접근제한자라는게 문제다.</p><p>그래서 <code>Clonable</code>를 구현한다고 해서 외부 객체에서 <code>clone</code> 메서드를 호출할 수 없다는 점이 아이러니한 점이다.</p><p>메서드 하나 없는 <code>Clonable</code> 인터페이스는 <code>Object</code> 클래스의 <code>protected</code> 메서드인 <code>clone</code> 메서드의 <strong>동작 방식을 결정한다</strong>.</p><p><code>Clonable</code> 인터페이스를 구현한 클래스의 인스턴스에서 <code>clone</code> 메서드를 호출하면 그 객체의 필드를 하나하나 복사한 객체를 반환하며, <code>Clonable</code> 인터페이스를 구현하지않은 클래스의 인스턴스에서 호출하면 <code>CloneNotSupportedException</code>을 반환한다.</p><p>이는 인터페이스를 상당히 이례적으로 사용한 예라고 하며 저자는 따라하지 말것을 강조했다.</p><p><code>Clonable</code>로 구현한 클래스는 <code>clone</code> 메서드를 <code>public</code>으로 제공하고 사용자는 당연히 복제가 제대로 이루어지리라 기대하게 된다.</p><p>그 기대에 대한 리턴은 <strong>깨지기 쉽고</strong>, <strong>위험하고</strong> <strong>모순적인</strong> 매커니즘이 탄생한다.</p><p>그 모순은 바로 <strong>생성자를 호출하지 않고도 객체를 생성할 수 있게 되어버리는 것이다</strong>.</p><p>예제를 봐보자.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@Override</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public PhoneNumber clone() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return (PhoneNumber) super.clone();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    } catch (CloneNotSupportedException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        throw new AssertionError(); // 일어날 수 없는 일</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Object 클래스의 <code>clone</code>을 호출하면 <code>Object</code> 타입이 반환되지만, <code>PhoneNumber</code>의 <code>clone</code> 메서드는 <code>PhoneNumber</code>을 반환하게 했다.</p><p>이를 자바에서 <code>convariant return typing</code>이라고 부르며 한국말로는 어렵게 <code>공변 변환 타이핑</code>이라고 부른다.</p><p>의미는 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있다는 것이다.</p><p>위 코드에서 사실상 예외는 일어나지 않는데 <code>clone</code> 메서드에서 예외를 던지다보니, 거추장한 코드가 되었다.</p><p><code>Clonable</code>을 구현한 클래스를 복제하는 것은 얼핏 보면 굉장히 편리해보이기도 하다.</p><p>그러나 <code>HashTable</code>과 같은 자료구조에서 <code>clone</code>은 버킷마다 리스트를 새롭게 생성하고, 원본 데이터의 키-값 쌍을 복제본 테이블의 <code>put</code> 메서드를 활용해 복사해주어야하는데 꽤 번거롭다. (Deep Copy 이슈)</p><p>일단 왜 이런 작업을 해야하는가에 대해 의문을 품을 수 있다.</p><p><code>clone</code> 메소드는 얼핏 보면 편리해보이지만, 사실은 쓰레드 안전하지 않으며 <code>Object</code>의 <code>clone</code> 자체가 동기화를 전혀 고려하지않았다.</p><p>그래서 <code>super.clone</code> 외에 별 다른 작업을 하지 않는다하더라도 <code>clone</code>을 오버라이딩해서 쓰레드 세이프하게 개발해주어야한다.</p><p>또한 <code>clone</code> 메소드 자체가 예외를 던지게끔 설계가 되어있다보니, 재정의하는 곳에서 <code>clone</code>의 예외를 없애주어야하며 <code>public</code> 접근제한자로 만들어주어야한다. (그래야 사용하기 편리하다.)</p><p>이를 요악해보면 <code>Object</code>의 <code>clone</code> 메서드는 어째, 잘못 만들어진 것 같아보이기도 하다.</p><p>저자 역시 <code>clone</code>을 사용하기 보다는 다른 방법으로 복사를 권장하고 있다.</p><p><code>Cloneable</code>을 이미 구현한 클래스를 확장한다면 어쩔 수 없지만, 그렇지 않은 상황이라면 가급적 <code>복사 생성자</code>와 <code>복사 팩터리</code>를 고려하는 것이 좋다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Yum(Yum yum) { ... }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static Yum newInstance(Yum yum) { ... };</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>복사 생성자와 그 변형인 복사 팩터리는 <code>Cloneable/clone</code> 방식보다 훨씬 더 나은 대안이다.</p><p>복사 생성자와 복사 팩터리는 해당 클래스가 구현한 <code>인터페이스</code> 타입의 인스턴스를 인수로 받을 수 있다는 강력한 강점이 있다.</p><p>복사 생성자/복사 팩터리의 더 정확한 이름은 <code>Conversion Constructor</code>와 <code>Conversion Factory</code>이다.</p><p>이를 이용해 클라이언트는 원본의 구현 타입에 얽매이지 않고, 복제본의 타입을 직접 선택할 수 있다.</p><p>저자 역시 새로운 인터페이스를 만들 때 <code>Cloneable</code>을 확장하지 말것을 강조하였고, 가급적이면 생성자와 팩터리를 이용하는 것이 최고라고 이야기하였다.</p><p>다만, 배열만큼은 <code>clone</code> 메서드를 사용하는 것이 예외적으로 가장 깔끔한 방법이라고 한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="comparable을-구현할지-고려하라"></a>Comparable을 구현할지 고려하라<a class="hash-link" href="#comparable을-구현할지-고려하라" title="Direct link to heading">#</a></h2><blockquote><p>item 14</p></blockquote><p>이번 장의 마지막에서는 <code>Comparable</code> 인터페이스의 유일한 메서드인 <code>compareTo</code>에 대해서 알아보자.</p><p>눈치 챘을지 모르겠지만, <code>compareTo</code>는 유일하게 이번 장에서 <code>Object</code>의 메서드가 아닌 메서드이다.</p><p>성격은 두 가지만 빼면 <code>Object</code>의 <code>equals</code>와 같다.</p><p><code>compareTo</code>와 <code>equals</code>와 다른 점 첫 번째는, 동치성 비교에 더해 <strong>순서</strong>까지 비교할 수 있다는 점이며, 제네릭하다는 것이다.</p><p>즉, <code>Comparable</code> 구현했다는 것은 해당 클래스의 인스턴스들에게 자연적인 순서가 있음을 의미한다.</p><p>사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거 타입은 <code>Comparable</code>를 구현하고 있다.</p><p>만약에 순서가 명확한 값 클래스를 작성한다면 반드시 <code>Comparable</code> 인터페이스를 구현하도록 하자.</p><p><code>compareTo</code>는 이전 <code>hashCode</code>와 마찬가지로 규약을 지켜야한다.</p><p>첫 번째 규약은 두 객체의 참조의 순서를 바꿔 비교해도 항상 예상한 결과가 나와야한다.</p><p>두 번째 규약은 첫 번째가 두 번째보다 크고 두 번째가 세 번째보다 크다면, 아래의 수식이다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">a &gt; b 이고,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">b &gt; c 라면,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">a &gt; c 이다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># 이산수학인가..?</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>마지막 규약은 크기가 같은 객체들 끼리는 어떤 객체와 비교하더라도 항상 같아야한다는 것이다.</p><p>위 세 규약은 반사성, 대칭성, 추이성을 충족해야한다는 것을 의미하기도 한다.</p><p><code>compareTo</code>의 마지막 규약은 필수는 아니지만, 지키게 되면 이는 <code>equals</code> 메서드와 같은 결과를 얻을 수 있게 된다.</p><p>물론 정렬된 컬렉션에서 <code>compareTo</code>의 결과가 <code>equals</code>의 결과와 다르더라도, 문제는 없다.</p><p>참고로 정렬된 컬렉션들은 동치성 비교에 <code>equals</code>가 아닌, <code>compareTo</code>를 사용한다.</p><p>그러니 이는 큰 문제는 아니지만 가급적 지켜주는 것이 좋다.</p><p>자바 8에서는 <code>Comparator</code> 인터페이스가 일련의 비교자 생성 메서드와 팀을 꾸려 메서드 연쇄 방식으로 비교자를 생성할 수 있게 지원한다.</p><p>이 방법은 간결하고 매력적이지만, 약간의 성능 저하가 있다고 한다.</p><p>모던 자바를 사용하는 프로젝트라면 이 방법을 적극 사용하는 편이 좋다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>순서를 고려해야하는 값 클래스를 만든다면 <code>Comparable</code> 인터페이스를 구현하여 그 인스턴스를 쉽게 정렬, 검색, 비교할 수 있게 하는 컬렉션과 어우러지도록 해야한다.</p><p>그리고 Primitive 타입의 비교가 필요하다면 박싱 클래스가 제공하는 정적 <code>compare</code> 메서드나 <code>Comparator</code> 인터페이스가 제공하는 비교자 생성 메서드를 사용하도록 하자.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reference"></a>Reference<a class="hash-link" href="#reference" title="Direct link to heading">#</a></h2><img width="360" alt="스크린샷 2021-04-16 오후 4 24 23" src="https://user-images.githubusercontent.com/43809168/114987533-3e449400-9ed0-11eb-9b5f-a24f73b6f138.png"><p>이펙티브 자바 Effective Java 3/E</p><p>저자 : 조슈아 블로크</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/minkukjo/study/edit/master/docs/java/effective-java/03-public-method.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-05-30T11:59:02.000Z" class="lastUpdatedDate_1WI_">5/30/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/study/docs/java/effective-java/02-object-create-destroy"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 02. 객체 생성 파괴</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/study/docs/java/effective-java/04-class-interface"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">04. 클래스와 인터페이스 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#eqauls는-일반-규약을-지켜-재정의하라" class="table-of-contents__link">eqauls는 일반 규약을 지켜 재정의하라</a></li><li><a href="#equals를-재정의하려거든-hashcode도-재정의하라" class="table-of-contents__link">equals를 재정의하려거든 hashCode도 재정의하라</a></li><li><a href="#tostring을-항상-재정의하라" class="table-of-contents__link">toString을 항상 재정의하라</a></li><li><a href="#clone-재정의는-주의해서-진행하라" class="table-of-contents__link">clone 재정의는 주의해서 진행하라</a></li><li><a href="#comparable을-구현할지-고려하라" class="table-of-contents__link">Comparable을 구현할지 고려하라</a></li><li><a href="#reference" class="table-of-contents__link">Reference</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Harry's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/study/assets/js/runtime~main.fcc2c37a.js"></script>
<script src="/study/assets/js/main.53ddd09a.js"></script>
</body>
</html>