<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/study/blog/rss.xml" title="도전하는 개발자 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/study/blog/atom.xml" title="도전하는 개발자 Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="도전하는 개발자" href="/study/opensearch.xml"><title data-react-helmet="true">02. 객체 생성 파괴 | 도전하는 개발자</title><meta data-react-helmet="true" property="og:url" content="https://minkukjo.github.io/study/docs/java/effective-java/02-object-create-destroy"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="02. 객체 생성 파괴 | 도전하는 개발자"><meta data-react-helmet="true" name="description" content="객체를 만들어야할 때와 만들어야하지 않을 때를 구분해야한다."><meta data-react-helmet="true" property="og:description" content="객체를 만들어야할 때와 만들어야하지 않을 때를 구분해야한다."><link data-react-helmet="true" rel="shortcut icon" href="/study/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://minkukjo.github.io/study/docs/java/effective-java/02-object-create-destroy"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/java/effective-java/02-object-create-destroy" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/java/effective-java/02-object-create-destroy" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://R6WS6DHCQH-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/study/assets/css/styles.2d555e26.css">
<link rel="preload" href="/study/assets/js/runtime~main.6e54e51d.js" as="script">
<link rel="preload" href="/study/assets/js/main.b6c5c469.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/study/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/study/blog">Blog</a><a class="navbar__item navbar__link" href="/study/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/study/docs/intro">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/study/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" href="/study/about">About</a></li><li class="menu__list-item"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/study/docs/intro">소개</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">JPA</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/jpa/kotlin-jpa-guide">Kotlin JPA 개발 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Security</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/security/spring-security-flow">Spring Security OAuth2 Login</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Code</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">리팩토링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/00-intro">00. 스터디 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/01-first">01. 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/02-principle">02. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/03-smell">03. 코드에서 나는 악취</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kubernetes</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">15단계로 배우는 쿠버네티스</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/00-intro">00. 스터디 시작의 계기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/01-what-is-k8s">01. 쿠버네티스란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/02-what-is-container">02. 컨테이너란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/03-kubernetes-architecture">03. 쿠버네티스의 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/04-docker-command">04. 도커 명령어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/05-docker-deeper">05. 도커 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/06-dockerfile">06. 컨테이너 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/07-container-network">07. 컨테이너 네트워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/08-container-api">08. 컨테이너 API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/09-kubernetes-first-step">09. 쿠버네티스 첫 걸음</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/10-manifest">10. 매니페스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/11-service">11. 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/12-ingress">12. 인그레스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/13-deplyoment">13. 디플로이먼트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/14-statefulset">14. 스테이트풀셋</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/15-autoscale">15. 오토스케일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/16-ingress-deeper">16. 인그레스 기능</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/17-storage">17. 스토리지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/18-job">18. Job과 Cron Job</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/node-isolation">특정 노드에만 파드 배포하기</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">이펙티브 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/01-intro">01. 소개</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/study/docs/java/effective-java/02-object-create-destroy">02. 객체 생성 파괴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/03-public-method">03. 모든 객체의 공통 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/04-class-interface">04. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/05-generic">05. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/06-enum-annotation">06. 이넘 타입과 애너테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/07-lambda-stream">07. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/08-method">08. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/09-programming-rule">09. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/10-exception">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/11-concurrency">11. 동시성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/java/effective-java/12-serialize">12. 직렬화</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kafka</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">카프카 핵심 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/03-consumer">03. 카프카 컨슈머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/05-internal">05. 카프카의 내부 메커니즘</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/07-data-pipeline">07. 데이터 파이프라인 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kafka/kafka-core-guide/11-streams">11. 스트림 프로세싱</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">02. 객체 생성 파괴</h1></header><div class="markdown"><blockquote><p>객체를 만들어야할 때와 만들어야하지 않을 때를 구분해야한다.</p></blockquote><blockquote><p>올바른 객체 생성과 파괴에 대해서 공부해보자.</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="생성자-대신-정적-팩터리-메서드를-고려하라"></a>생성자 대신 정적 팩터리 메서드를 고려하라<a class="hash-link" href="#생성자-대신-정적-팩터리-메서드를-고려하라" title="Direct link to heading">#</a></h2><blockquote><p>item 01</p></blockquote><p>static 메소드를 사용하여 생성자를 대체할 수 있다.</p><p>생성자 대신 정적 메소들르 사용하는 것에 어떤 이점이 있을까?</p><p><strong>첫 번째</strong>, 이름을 가질 수 있다.</p><p>소수를 반환하는 메소드를 생각해볼 때,</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly Java"><div tabindex="0" class="prism-code language-Java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">BigInteger(int, int, Random)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">VS</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BigInteger.probablePrime()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>무조건 아래쪽이 더 의미가 가깝다고 느껴진다.</p><p>이는 클린코드에서 나온 내용과도 일맥상통하는 내용이다.</p><p>생성자 대신 정적 메소드를 통해 하고자하는 행위가 이름을 가진다는 것은 읽는 사람으로 하여금 결국 더욱 더 코드를 풍부하게 만들어준다.</p><p><strong>두 번째</strong>, 호출될 때 마다 인스턴스를 새로 생성하지는 않아도 된다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Boolean.valueOf(boolean)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위 코드는 내부적으로 객체를 아예 생성하지않는다.</p><p>인스턴스를 캐싱해놓고 재활용하기 때문에 불필요한 객체 생성을 줄일 수 있다.</p><p><code>플라이웨이트 패턴(FlyWeight Pattern)</code>이라는 디자인 패턴도 이와 비슷한 기법이라고 한다.</p><p><strong>세 번째</strong>, 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.</p><p>생성자는 반드시 생성하려는 생성자에 해당하는 타입이 반환되지만, 정적 메소드를 사용하면 하위 타입의 객체도 반환이 가능하다.</p><p>자바 8이전에는 인터페이스에 정적 메서드를 선언할 수 없어서, 인터페이스 내부에 <code>Companion Class</code>를 두는 것이 관례였다.</p><p>자바 8 이후부터 <code>Default Method</code>가 등장하면서 <code>Companion Class</code>를 둘 이유가 사라졌다.</p><p><strong>네 번째</strong>, 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.</p><p>EnumSet 클래스는 생성자 없이 오직 정적 팩터리 메서드만 제공한다.</p><p>엘리먼트가 64개 이하면 <code>RegualrEnumSet</code>을, 65개 이상이면 <code>JumboEnumSet</code>을 반환해준다.</p><p>클라이언트 입장에서는 팩터리가 건네주는 객체가 클래스의 인스턴스인지를 모르고, 알 필요도 없다.</p><p>만약 <code>RegualrEnumSet</code>을 굳이 쓸 필요가 없다면 지워버리면 그만이다.</p><p><strong>다섯 번째</strong>, 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</p><p>이러한 유연함은 서비스 제공자 프레임워크를 만드는데 근간이 되는데, 대표적으로 JDBC가 있다.</p><p>구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트는 구현체를 모르더라도 해당 기능을 사용할 수 있게 해준다.</p><p>서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어진다.</p><p><strong>Service Interface</strong>, <strong>Provider Registration API</strong>, <strong>Service Access API</strong></p><p>클라이언트는 <strong>Service Access API</strong>를 사용할 때 원하는 구현체의 조건을 명시해줄 수 있다.</p><p>만약 조건이 없다면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환해준다.</p><p>이 <strong>Service Access API</strong>가 바로 서비스 제공자 프레임워크의 근간인 <strong>유연한 정적 팩터리</strong>이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정적-메서드-팩토리의-단점"></a>정적 메서드 팩토리의 단점<a class="hash-link" href="#정적-메서드-팩토리의-단점" title="Direct link to heading">#</a></h3><p><strong>첫 번째</strong> 상속을 하려면 public, protected 생성자가 필요하니, 정적 팩터리 메소드만 제공하면 하위 클래스를 만들어낼 수 없다.</p><p>물론 이러한 패턴이 상속을 지양하고 컴포지션을 유도하다보니, 이게 어떻게 보면 장점이 될 수도 있다.</p><p><strong>두 번째</strong>, 정적 팩터리 메서드는 프로그래머가 찾기가 어렵다.</p><p>생성자처럼 API 설명에 명확히 드러나지가 않아서 문서를 읽어봐야한다.</p><p>그러나 요즘은 IDE가 좋아서 딱히..?</p><p>정적 팩토리 메서드의 예시는 다음과 같다.</p><p><code>from</code>: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드.</p><p><code>of</code>: <code>from</code>과 다르게 여러 매개변수를 받는다.</p><p><code>valueOf</code>: <code>from</code>과 <code>of</code>보다 더 자세한 버전</p><p><code>instance</code> : 혹은 <code>getInstance</code> 매개변수로 명시한 인스턴스를 반환하지만 같은 인스터임을 보장해주진 않는다.</p><p><code>create</code>: 혹은 <code>newInstance</code> 항상 새로운 인스턴스를 생성해 반환해준다.</p><p><code>getType</code>: 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 생성할 때 사용한다. 여기서 Type은 해당 팩터리 메서드가 반환할 객체의 타입을 적어준다. e.q. ) getMember(name)</p><p><code>newType</code>: 다른 클래스에 새로운 인스턴스를 생성하여 반환할 때 사용한다.</p><p><code>type</code>: <code>getType</code>과 <code>newType</code>의 간결 버전</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="생성자에-매개변수가-많다면-빌더를-고려하라"></a>생성자에 매개변수가 많다면 빌더를 고려하라<a class="hash-link" href="#생성자에-매개변수가-많다면-빌더를-고려하라" title="Direct link to heading">#</a></h2><blockquote><p>item 02</p></blockquote><p>매개변수가 많은 함수는 가급적 피하는게 좋다는 것을 이미 클린코드에서 배웠다.</p><p>생성자 역시 너무 많은 매개변수와 다양한 생성자를 클래스가 갖게 되면 개발자 입장에서 사용하기가 여간 껄끄럽다.</p><p>결국 매개변수가 많은 생성자는 <strong>코드의 가독성을 떨어뜨린다</strong></p><p>이를 위해 자바빈즈(Java Beans) 패턴을 사용할 수 있는데 아래와 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Member member = new Member();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">member.setId(1L);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">member.setName(&quot;harry&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">member.setAge(18);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">member.setMoney(0L);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 자바 빈즈 패턴은 심각한 단점을 갖고 있는데, 보다시피 <strong>객체 하나를 만들기 위해 여러 메서드를 호출해야한다</strong>는 점이다.</p><p>또한 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.</p><p>자바빈즈 패턴이 유발하는 또 다른 문제는 클래스를 불변으로 만들 수 없으며 스레드 안정성을 얻으려면 프로그래머가 추가 작업을 해줘야만 한다는 점이다.</p><p>이를 위한 가장 완벽한 대안은 <strong>빌더 패턴</strong>을 사용해보는 것이다.</p><p>빌더 패턴으로 위 멤버를 생성해보면 다음과 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Member member = new Member.Builder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    .id(1L)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    .name(&quot;harry&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    .age(18)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                    .money(0L);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>어떤가? 이전보다 훨씬 읽기 쉽고 단순하고 명확해졌다.</p><p>빌더 패턴은 자바 API에서도 심심치않게 등장하며 <code>Lombok</code>을 사용한다면 이 빌더를 자동으로 만들어준다는 장점이 있다.</p><p>생성자나 정적 팩터리가 처리해야할 매개변수가 많다면 처음부터 빌더 패턴을 고려해보는 것이 더 낫다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인스턴스화를-막으려거든-private-생성자를-사용하라"></a>인스턴스화를 막으려거든 private 생성자를 사용하라<a class="hash-link" href="#인스턴스화를-막으려거든-private-생성자를-사용하라" title="Direct link to heading">#</a></h2><blockquote><p>item 03</p></blockquote><p>생성자를 명시하지않으면 컴파일러가 Default 생성자를 만들어주는 것은 자바 개발자라면 이미 다 알고 있는 사실이다.</p><p>여기서 이 객체가 정적 메서드와 정적 필드만을 담은 Util 클래스라면 인스턴스화를 굳이 할 필요가 없으므로 이를 막아야한다.</p><p>쉽게 막을 수 있는 방법은 <code>Private 생성자</code>를 선언하는 것인데, 가령 아래와 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class UtilClass {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private UtilClass() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        throw new AssertionError();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이 코드는 어떤 상황에서도 클래스가 인스턴스화 되는 것을 막아준다.</p><p>생성자가 분명히 존재하는데 호출 할 수 없으므로 적절한 주석을 달아줄 것을 저자는 명하고 있으나, 클린코드에서 주석은 가급적 지양하자고 했으니 난 안쓰겠다.</p><p>어쨌든, 이런식으로 생성자를 <code>Private</code>으로 만들어버리면 상속을 불가능하게 막는 효과도 있다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="private-생성자나-열거-타입으로-싱글턴임을-보증하라"></a>Private 생성자나 열거 타입으로 싱글턴임을 보증하라<a class="hash-link" href="#private-생성자나-열거-타입으로-싱글턴임을-보증하라" title="Direct link to heading">#</a></h2><blockquote><p>item 04</p></blockquote><p>싱글턴은 인스턴스를 오직 하나만 생성할 수 있는 클래스 생성 패턴을 말한다.</p><p>싱글턴 클래스의 단점은 <strong>클라이언트가 테스트 하기가 어렵다</strong>라는 점인데, 왜 그럴까?</p><p>그 이유는 인터페이스로 정의한 다음 그 인터페이스를 구현한 싱글턴 인스턴스가 아니라면, Mock 객체로 구현해 대체할 수 없기 떄문이다.</p><p>싱글턴 오브젝트 생성에는 여러 방법이 있지만, 이 책에서 가장 선호하는 싱글턴 오브젝트 방법은 원소가 하나인 열거 타입을 만드는 것이다.</p><p>아래와 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public enum Elvis {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    INSTANCE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    public void leaveTheBuilding() { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>어찌보면 좀 어색해 보이지만, 대부분 상황에서 원소가 하나뿐인 열거타입이 싱글턴을 만드는 가장 좋은 방법이라고 저자는 소개하고 있다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자원을-직접-명시하지-말고-의존-객체-주입을-사용하라"></a>자원을 직접 명시하지 말고 의존 객체 주입을 사용하라<a class="hash-link" href="#자원을-직접-명시하지-말고-의존-객체-주입을-사용하라" title="Direct link to heading">#</a></h2><blockquote><p>item 05</p></blockquote><p>하나의 클래스 안에서 다른 클래스를 사용할 때 종종 클래스 내에서 정적 변수로 선언하여 사용하는 것을 심심치않게 볼 수 있다.</p><p>이는 유연하지 못하고 테스트를 어렵게 만든다.</p><p>고로, 사용하려는 클래스를 의존성 주입을 통해 사용하게 하는 것이 바람직하다.</p><p>아래와 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Harry {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private final Laptop laptop;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    public Harry(Laptop laptop) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        this.laptop = Objects.requireNonNull(laptop);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 생성자를 통한 의존성 주입은 <code>Spring Framework</code>에서도 적극 권장하고 있는 방식이기도 하다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="불필요한-객체-생성을-피하라"></a>불필요한 객체 생성을 피하라<a class="hash-link" href="#불필요한-객체-생성을-피하라" title="Direct link to heading">#</a></h2><blockquote><p>item 06</p></blockquote><p>똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 더 낫다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">String s = new String(&quot;harry&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위 코드는 매우 나쁜 코드이다. 실행될 때 마다 String 인스턴스를 새롭게 만든다.</p><p>생성자에 넘어가는 <code>harry</code>라는 문자열이 생성자로 만드려는 <code>String</code>과 일치한다.</p><p>개선해보자.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">String s = &quot;harry&quot;;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>만약 정규식 검증과 같이 비싼 작업이라면 매번 실행될 때 마다 호출하기 보다는, 정적 멤버로 만들어서 캐싱해두고 재사용을 하는 편이 더 낫다.</p><p>이러한 패턴의 안좋은 예는 아래와 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private static long sum() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Long sum = 0L;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for(long i=0; i&lt;=Integer.MAX_VALUE; i++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        sum += i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return sum;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>문제점을 찾았는가?</p><p>저자는 이 코드를 동작시키는데 6.5초가 걸렸고, sum의 박싱타입인 Long을 long으로 바꾸기만 했는데 0.59초로 빨라졌다고 말하고 있다.</p><p>즉, Primitive 타입을 박싱 타입으로 선언하면 자동으로 언박싱을 하게 되는데, 이 과정에서 꽤 많은 연산이 생긴다는 것을 알 수 있다.</p><p>그렇다고 해서 이번 주제를 <code>객체 생성은 비싸니 피해야한다</code>로 오해해서는 안된다.</p><p>요즘같은 메모리가 싸고 널널한데다가 나날이 올라가는 가비지 콜렉터의 성능을 가진 JVM에서 이정도 작은 객체 생성과 회수는 크게 부담되는 일은 아니다.</p><p>그렇다고 해서 별로 비싸지도 않은 객체의 <code>Cusmtom Pool</code>을 만들어 관리하지는 말자.</p><p>DB 연결이야 워낙 비용이 비싸니 재사용하는 편이 낫다지만, 작은 객체까지 그럴 필요는 없다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다-쓴-객체-참조를-해제하라"></a>다 쓴 객체 참조를 해제하라<a class="hash-link" href="#다-쓴-객체-참조를-해제하라" title="Direct link to heading">#</a></h2><blockquote><p>item 07</p></blockquote><p>C, C++ 처럼 가비지 콜렉터가 없고 메모리를 직접 관리해야하는 언어로 개발을 하다가 자바로 넘어오면 그야말로 신세계다.</p><p>그래서 개발자들은 자칫 메모리 관리를 안해도 된다고 오해할 수 있으나 이는 사실이 아니다.</p><p>메모리 누수( OOM )과 같은 현상은 자바에서 종종 접하게 되는 이슈이며 이를 잘 관리해줘야한다.</p><p>그러나 가비지콜렉터를 지원하는 언어에서 이런 메모리 누수는 찾기가 어렵다.</p><p>그래서 사용이 끝나면 변수에 <code>data=null</code>을 넣음으로써 참조를 끊어주게 되면, 해당 인스턴스는 그 즉시 가비지 컬렉터의 수집 대상이 되므로 손쉽게 메모리 회수가 가능하다.</p><p>자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항상 메모리 누수에 주의해야한다.</p><p>캐시 역시 메모리 누수를 일으키는 주범이다.</p><p>캐시가 필요한 상황이라면 <code>WeakHashMap</code>을 사용해 캐시를 만들어보자.</p><p>다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다.</p><p>메모리 누수의 또 다른 주범은, 리스너 또는 콜백이라 부르는 친구들이다.</p><p>클라이언트가 콜백을 등록해두고 명확하게 해지하지않고 놔두면 계속해서 콜백이 쌓이게 된다.</p><p>이 때 콜백을 <code>weak reference</code>로 저장하면 가비지 컬렉터가 그 즉시 수거해가므로 예방해볼 수 있다.</p><p>에를 들어, <code>WeakHashMap</code>에 키로 저장하면 된다.</p><p>이러한 메모리 누수는 철저한 코드리뷰나 힙 프로파일러와 같은 디버깅 도구를 동원해야만 발견되기도 한다.</p><p>그래서 이런 종류의 문제는 예방법을 미리 익혀두는 것이 좋다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizer와-cleaner-사용을-피하라"></a>finalizer와 cleaner 사용을 피하라<a class="hash-link" href="#finalizer와-cleaner-사용을-피하라" title="Direct link to heading">#</a></h2><blockquote><p>item 08</p></blockquote><p>finalizer는 예측할 수 없고 상황에 따라 위험할 수 있어 사용하지않는 편이 좋다.</p><p>자바 9에서는 finalizer의 사용을 자제하며 (Deprecated) cleaner를 그 대안으로 했으나 이 역시도 좋지 않다.</p><p>cleaner는 여전히 예측할 수 없고, 느리며, 일반적으로 불필요하다.</p><p>자바에서는 메모리 자원의 회수를 위해 자바 7에서 제공하는 <code>try-with-resource</code>와 <code>try-finally</code>를 사용해 해결하는 편이 좋다.</p><p>그럼 이 finalizer와 cleaner는 도당체 언제 쓰인단 말인가?</p><p>첫 번째는, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주기 위한 안전망의 역할로써 finalizer를 사용해볼 수 있다.</p><p>안전망으로써 finalizer를 사용하는 자바 라이브러리는 <code>FileInputStream</code>과 <code>FileOutputStream</code>, <code>ThraedPoolExecutor</code>가 있다.</p><p>두 번째는, 네이티브 피어(native peer)와 연결된 객체이다.</p><p>네이티브 피어란, 쉽게 말해 자바 객체가 아닌 (가비지 컬렉터의 대상이 되지 않는) 네이티브 메서드를 통해 기능을 위임받은 네이티브 객체를 의미한다.</p><p>이 때 자원을 회수하려는 목적으로 finalizer와 cleaner를 써볼 수 있는데, 이 역시도 네이티브 피어가 비싼 자원을 갖고 있지 않을 때에만 사용해볼 수 있다.</p><p>네이티브 피어가 사용하는 자원을 즉시 회수해야한다면 <code>close</code> 메소드를 사용하자.</p><p>즉, cleaner는 중요하지 않은 네이티브 피어 객체의 회수 용도로만 사용하자.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="try-finally-보다는-try-with-resources를-사용하라"></a>try-finally 보다는 try-with-resources를 사용하라<a class="hash-link" href="#try-finally-보다는-try-with-resources를-사용하라" title="Direct link to heading">#</a></h2><blockquote><p>item 09</p></blockquote><p>자바 7에서 추가된 <code>try-with-resources</code>는 자원을 효과적으로 회수할 수 있는 기법이다.</p><p>이는 <code>AutoCloseable</code>을 구현한 객체라면, try 구문이 끝날 때 <code>close</code>를 호출해서 알아서 자원을 호출해간다.</p><p>그러니 자원을 사용 후 반환해야하는 클래스가 필요하다면 <code>AutoCloseable</code>를 확장해 사용하도록 하자.</p><p><code>try-with-resources</code>의 예시는 아래와 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static String firstLineOfFile(String path, String defaultVal) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try(BufferedReader br = new BufferedReader(new FileReader(path))) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return br.readLine();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    } catch (IOException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return defaultVal;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reference"></a>Reference<a class="hash-link" href="#reference" title="Direct link to heading">#</a></h2><img width="360" alt="스크린샷 2021-04-16 오후 4 24 23" src="https://user-images.githubusercontent.com/43809168/114987533-3e449400-9ed0-11eb-9b5f-a24f73b6f138.png"><p>이펙티브 자바 Effective Java 3/E</p><p>저자 : 조슈아 블로크</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/minkukjo/study/edit/master/docs/java/effective-java/02-object-create-destroy.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-04T11:08:37.000Z" class="lastUpdatedDate_1WI_">7/4/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/study/docs/java/effective-java/01-intro"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 01. 소개</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/study/docs/java/effective-java/03-public-method"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">03. 모든 객체의 공통 메서드 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#생성자-대신-정적-팩터리-메서드를-고려하라" class="table-of-contents__link">생성자 대신 정적 팩터리 메서드를 고려하라</a><ul><li><a href="#정적-메서드-팩토리의-단점" class="table-of-contents__link">정적 메서드 팩토리의 단점</a></li></ul></li><li><a href="#생성자에-매개변수가-많다면-빌더를-고려하라" class="table-of-contents__link">생성자에 매개변수가 많다면 빌더를 고려하라</a></li><li><a href="#인스턴스화를-막으려거든-private-생성자를-사용하라" class="table-of-contents__link">인스턴스화를 막으려거든 private 생성자를 사용하라</a></li><li><a href="#private-생성자나-열거-타입으로-싱글턴임을-보증하라" class="table-of-contents__link">Private 생성자나 열거 타입으로 싱글턴임을 보증하라</a></li><li><a href="#자원을-직접-명시하지-말고-의존-객체-주입을-사용하라" class="table-of-contents__link">자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</a></li><li><a href="#불필요한-객체-생성을-피하라" class="table-of-contents__link">불필요한 객체 생성을 피하라</a></li><li><a href="#다-쓴-객체-참조를-해제하라" class="table-of-contents__link">다 쓴 객체 참조를 해제하라</a></li><li><a href="#finalizer와-cleaner-사용을-피하라" class="table-of-contents__link">finalizer와 cleaner 사용을 피하라</a></li><li><a href="#try-finally-보다는-try-with-resources를-사용하라" class="table-of-contents__link">try-finally 보다는 try-with-resources를 사용하라</a></li><li><a href="#reference" class="table-of-contents__link">Reference</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Harry's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/study/assets/js/runtime~main.6e54e51d.js"></script>
<script src="/study/assets/js/main.b6c5c469.js"></script>
</body>
</html>