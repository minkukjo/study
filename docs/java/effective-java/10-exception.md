---
id: 10-exception
title: 10. 예외
---

> 예외를 제대로 활용하면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만 잘못 사용하면 역효과만 나타나는 양날의 검이다.

## 예외는 진짜 예외 상황에서만 사용하라

> item 69

```java
try {
  int i = 0;
  while(true)
    range[i++].climb();
} catch ( ArrayIndexOutOfBoundException e) {

}
```

- 이번 아이템은 이 코드 하나로 설명이 끝난다.

- 배열의 인덱스를 탐색하다가 마지막 부분에서 `ArrayIndexOutOfBoundException` 예외가 발생하면 끝을 내는 코드이다.

- 예외를 써서 루프를 종료시키는 방법은 아주 나쁘다. 가령 다음 표준 관용구를 사용한 반복문 코드보다 나은 점이 없다.

```java
for(Mountatin m : range) {
  m.climb();
}
```

### 예외를 사용한 종료가 나쁜 이유

- 예외는 에외 상황에 쓸 용도로 설계된 것이다.

- 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.

- 예외를 사용한 쪽이 표준 관용구보다 훨씬 느리다.

### 요약

- 예외는 예외 상황에서만 쓰자

- 정상적인 제어 흐름에서 사용해서는 안되며 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.

## 복구할 수 있는 상황에서는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

> item 70

- 자바에서는 문제 상황을 알리는 `Throwable` 타입으로 **검사 예외**, **런타임 예외**, **에러** 이렇게 총 세 가지를 제공한다.

- 호출하는 쪽에서 복구하리라 여겨지는 상황이면 검사 예외를 사용하는 편이 좋다.

- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자. 가령 배열의 인덱스 범위를 넘는 경우와 같이 말이다.

- 에러의 경우 JVM 자원 부족, 불변식 깨짐 등 더 이상 수행할 수 없는 경우를 나타낼 때 사용한다.

- **Exception**, **RuntimeException**, **Error**를 상속하지 않는 Throwable을 만들수도 있지만 그렇게 하지 않는게 더 좋다.

### 요약

- 복구할 수 있는 상황이라면 검사 예외

- 프로그래밍 오류라면 비검사 예외 (확실하지 않은 경우)

- 검사 예외도 아니오, 런타임 예외도 아닌 **Throwable**은 정의하지도 말자.

- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

## 필요 없는 검사 예외 사용은 피하라

- 일반적으로 예외를 발생하면 해당 메소드에서 **catch**로 잡아두던가, 더 바깥으로 던져서 문제를 전파시켜야한다.

- 어느쪽이든 API 사용자에게 부담을 주는 행위이며, 심지어 자바 8의 스트림 안에서는 직접 사용이 안되기 때문에 부담이 커졌다. (실제로 많이 겪은 이슈, 스트림 내부에서 예외를 잡을 수는 있는데 코드가 매우 지저분해짐)

- 그렇기에 가급적이면 검사 예외를 안던지는 방향을 고민해볼 필요가 있다.

## Reference

<img width="360" alt="스크린샷 2021-04-16 오후 4 24 23" src="https://user-images.githubusercontent.com/43809168/114987533-3e449400-9ed0-11eb-9b5f-a24f73b6f138.png"/>

이펙티브 자바 Effective Java 3/E

저자 : 조슈아 블로크
