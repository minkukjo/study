<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/study/blog/rss.xml" title="도전하는 개발자 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/study/blog/atom.xml" title="도전하는 개발자 Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="도전하는 개발자" href="/study/opensearch.xml"><title data-react-helmet="true">07. 데이터 파이프라인 구축하기 | 도전하는 개발자</title><meta data-react-helmet="true" property="og:url" content="https://minkukjo.github.io/study/docs/kafka/kafka-core-guide/07-data-pipeline"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="07. 데이터 파이프라인 구축하기 | 도전하는 개발자"><meta data-react-helmet="true" name="description" content="카프카로 데이터 파이프라인을 구축하는 방법에 대해 알아보겠습니다."><meta data-react-helmet="true" property="og:description" content="카프카로 데이터 파이프라인을 구축하는 방법에 대해 알아보겠습니다."><link data-react-helmet="true" rel="shortcut icon" href="/study/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://minkukjo.github.io/study/docs/kafka/kafka-core-guide/07-data-pipeline"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/kafka/kafka-core-guide/07-data-pipeline" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://minkukjo.github.io/study/docs/kafka/kafka-core-guide/07-data-pipeline" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://R6WS6DHCQH-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/study/assets/css/styles.2d555e26.css">
<link rel="preload" href="/study/assets/js/runtime~main.24c4b89c.js" as="script">
<link rel="preload" href="/study/assets/js/main.d36122be.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/study/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/study/blog">Blog</a><a class="navbar__item navbar__link" href="/study/about">About</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/study/"><strong class="navbar__title">Home</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/study/docs/intro">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/study/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" href="/study/about">About</a></li><li class="menu__list-item"><a href="https://github.com/minkukjo" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://minkukjo.github.io/" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/study/docs/intro">소개</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">JPA</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/jpa/kotlin-jpa-guide">Kotlin JPA 개발 가이드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Security</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/spring/security/spring-security-flow">Spring Security OAuth2 Login</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Code</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">리팩토링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/00-intro">00. 스터디 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/01-first">01. 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/02-principle">02. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/03-smell">03. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/04-test">04. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/code/refactoring/05-catalog">05. 리팩터링 카탈로그 보는 법</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kubernetes</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">15단계로 배우는 쿠버네티스</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/00-intro">00. 스터디 시작의 계기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/01-what-is-k8s">01. 쿠버네티스란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/02-what-is-container">02. 컨테이너란 무엇인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/03-kubernetes-architecture">03. 쿠버네티스의 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/04-docker-command">04. 도커 명령어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/05-docker-deeper">05. 도커 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/06-dockerfile">06. 컨테이너 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/07-container-network">07. 컨테이너 네트워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/08-container-api">08. 컨테이너 API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/09-kubernetes-first-step">09. 쿠버네티스 첫 걸음</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/10-manifest">10. 매니페스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/11-service">11. 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/12-ingress">12. 인그레스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/13-deplyoment">13. 디플로이먼트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/14-statefulset">14. 스테이트풀셋</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/15-autoscale">15. 오토스케일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/16-ingress-deeper">16. 인그레스 기능</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/17-storage">17. 스토리지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/15steps/18-job">18. Job과 Cron Job</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/kubernetes/node-isolation">특정 노드에만 파드 배포하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">이펙티브 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/01-intro">01. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/02-object-create-destroy">02. 객체 생성 파괴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/03-public-method">03. 모든 객체의 공통 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/04-class-interface">04. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/05-generic">05. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/06-enum-annotation">06. 이넘 타입과 애너테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/07-lambda-stream">07. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/08-method">08. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/09-programming-rule">09. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/10-exception">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/11-concurrency">11. 동시성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/study/docs/java/effective-java/12-serialize">12. 직렬화</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Kafka</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">카프카 핵심 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kafka/kafka-core-guide/03-consumer">03. 카프카 컨슈머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kafka/kafka-core-guide/05-internal">05. 카프카의 내부 메커니즘</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/study/docs/kafka/kafka-core-guide/07-data-pipeline">07. 데이터 파이프라인 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/study/docs/kafka/kafka-core-guide/11-streams">11. 스트림 프로세싱</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">07. 데이터 파이프라인 구축하기</h1></header><div class="markdown"><blockquote><p>카프카로 데이터 파이프라인을 구축하는 방법에 대해 알아보겠습니다.</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-파이프라인이란"></a>데이터 파이프라인이란<a class="hash-link" href="#데이터-파이프라인이란" title="Direct link to heading">#</a></h2><p>아파치 카프카를 사용하여 데이터 파이프라인을 구축할 때 사용하는 두 가지 케이스가 있습니다.</p><p><strong>첫 번째</strong>는 아파치 카프카가 두 개의 엔드 포인트 중 하나가 되는 데이터 파이프라인 구축하는 경우입니다.</p><p>이 경우 카프카는 일종의 엔드포인트가 되며, 이 때 개발자는 <strong>카프카의 데이터를 어떻게 엘라스틱서치로 가져올까</strong>?에 대한 해답을 <strong>카프카를 엔드포인트로 사용하자</strong>!로 내리게 됩니다.</p><p>그러나 이는 잘못된 설계일 수 있다고 저자는 지적하고 있는데요.</p><p>저자는 데이터 통합을 위해서 카프카를 중심으로 해서 두 개 이상의 시스템을 엔드 포인트로 갖게 하는 편이 좋다고 말하고 있습니다.</p><p>데이터 통합 문제에서 당장 필요한 엔드포인트 보다는 더 큰 관점을 고려할 것을 권장하고 있습니다.</p><p><strong>두 번째</strong> 케이스는 일반적으로 서로 다른 시스템 중간에서 카프카를 중개 역할로 사용하는 파이프라인 구축입니다.</p><p>가장 일반적인 카프카의 사용 방법이기도 하고 많은 기업들이 이러한 구조를 갖고 있습니다.</p><p><img src="https://user-images.githubusercontent.com/43809168/120889305-65e5ec00-c637-11eb-98ed-487cf8398115.png" alt="kafka_02"></p><p>이번 시간에는 카프카에서 제공하는 카프카 커넥트 API가 일반적인 프로듀서, 컨슈머 클라이언트와 어떻게 다른지 카프카 커넥트에 대해 조금 더 자세하게 살펴보겠습니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-파이프라인-구축-시-고려사항"></a>데이터 파이프라인 구축 시 고려사항<a class="hash-link" href="#데이터-파이프라인-구축-시-고려사항" title="Direct link to heading">#</a></h2><p>데이터 파이프라인을 구축할 때 몇 가지 고려해야할 것들이 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="적시성"></a>적시성<a class="hash-link" href="#적시성" title="Direct link to heading">#</a></h3><ul><li><p>하루에 한 번 대량의 데이터를 받는 시스템이 있는 반면, 데이터 생성 즉시 수 밀리초 안에 받아야하는 실시간 처리 시스템 두 가지가 있을 때 카프카는 그 중간정도의 포지션을 갖고 있음</p></li><li><p>카프카는 시간 단위의 배치 든 실시간 처리든 데이터를 적시에 전송하고 받을 수 있는 구조여야함</p></li><li><p>이게 가능한 이유는 데이터의 쓰기와 읽기가 분리되어 있기 때문</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="신뢰성"></a>신뢰성<a class="hash-link" href="#신뢰성" title="Direct link to heading">#</a></h3><ul><li><p>단일 장애점을 피하고 모든 종류의 장애 발생에 신속하고 자동화된 복구를 할 수 있어야함</p></li><li><p>카프카는 가용성과 신뢰성을 6장에서 보장하였으며, 자체적으로 <strong>최소 한 번</strong> 데이터 전달을 제공한다.</p></li><li><p>카프카 커넥트는 외부 시스템과의 데이터 통합에 필요한 API를 제공하므로 <strong>정확히 한 번</strong> 데이터 전달 파이프라인을 더 쉽게 구축할 수 있음</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="높으면서도-조정-가능한-처리량"></a>높으면서도 조정 가능한 처리량<a class="hash-link" href="#높으면서도-조정-가능한-처리량" title="Direct link to heading">#</a></h3><ul><li><p>카프카는 매우 높은 <strong>Throughput</strong>을 갖도록 확장할 수 있어야 하며 불시에 처리량이 증가하더라도 조정할 수 있어야 한다.</p></li><li><p>카프카는 평범한 클러스터에서도 초당 <strong>수백 메가 바이트</strong>를 처리할 수 있는 고성능 애플리케이션이다.</p></li><li><p>즉 카프카가 요구사항에 맞게 확장되지 못할 것이라는 걱정은 필요 없다.</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-형식"></a>데이터 형식<a class="hash-link" href="#데이터-형식" title="Direct link to heading">#</a></h3><ul><li><p>카프카와 카프카 커넥트 API는 데이터 형식에 구애받지 않는다. (변환기를 사용하면 어떤 형식으로도 데이터 저장 가능)</p></li><li><p>ES는 JSON, 하둡은 Parquet(파케이), 아마존 S3는 CSV 형식을 받는데 카프카 커넥트 API는 이 모두를 지원한다.</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="변환"></a>변환<a class="hash-link" href="#변환" title="Direct link to heading">#</a></h3><ul><li><p>카프카는 ETL과 ELT를 모두 지원한다.</p></li><li><p>ETL은 들어본적 있는데, ELT의 경우 대상 시스템에 전달되는 데이터가 원본 데이터와 최대한 유사하게 전달하기 위함이라고 한다.</p></li><li><p>그래서 대용량 데이터를 ELT로 처리하면 대상 시스템의 부하가 있을 수 있다고 한다.</p></li><li><p>ETL과 ELT의 차이는 <strong>누가 데이터 변환의 책임을 가지냐</strong>가 핵심인 것 같다</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="보안"></a>보안<a class="hash-link" href="#보안" title="Direct link to heading">#</a></h3><ul><li><p>파이프라인을 거쳐 가는 데이터가 암호화된다고 확신, 보장할 수 있는가?</p></li><li><p>파이프라인을 수정할 수 있도록 허용된 사람은 누구인가?</p></li><li><p>접근이 제어된 시스템에서 데이터를 파이프라인으로 읽거나 쓸 때, 인증 기능을 올바르게 사용하고 있는가?</p></li><li><p>카프카는 데이터 전송시 암호화된 데이터의 네트워크 전송을 허용하고, SASL(Simple Authentication and Security Layer) 인증을 지원한다.</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="장애-처리"></a>장애 처리<a class="hash-link" href="#장애-처리" title="Direct link to heading">#</a></h3><ul><li>카프카는 모든 데이터를 긴 시간동안 저장하므로 장애가 발생하면 해당 시점에 맞게 이전으로 돌아가서 에러를 복구할 수 있다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결합과-민첩성"></a>결합과 민첩성<a class="hash-link" href="#결합과-민첩성" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="임기응변식-파이프라인"></a>임기응변식 파이프라인<a class="hash-link" href="#임기응변식-파이프라인" title="Direct link to heading">#</a></h4><p>ES와 Logstash는 ELK 스택이라고도 불리며 환상의 짝꿍으로 불리지만, 로그스태시라는 데이터 파이프라인을 구성하게 되면 커스텀 애플리케이션들이 이런 엔드포인트와 강하게 결합되어서 이후 유지보수가 어렵게 될 수 있습니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메타데이터-유실"></a>메타데이터 유실<a class="hash-link" href="#메타데이터-유실" title="Direct link to heading">#</a></h4><p>데이터 파이프라인이 스키마 메타데이터를 보존하지않고 스키마의 진화를 허용하지 않으면, 데이터를 생성하는 쪽과 소비하는 쪽 간의 강결합이 발생하게 됩니다.</p><p>파이프라인이 스키마 데이터를 갖고 있질 않으면 다른 두 시스템이 스키마에 대한 정보를 각자 갖고 있을 수 밖에 없습니다.</p><p>만약 오라클 DB로 부터 HDFS로 데이터가 이동하는 구조에서 오라클 DB에 컬럼이 추가되면 HDFS로부터 데이터를 읽는 모든 애플리케이션이 중단될 것입니다.</p><p>반대로 파이프라인에서 스키마 진화를 지원한다면 각 시스템들은 유연하게 변경할 수 있을 것입니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="과도한-처리"></a>과도한 처리<a class="hash-link" href="#과도한-처리" title="Direct link to heading">#</a></h4><p>파이프라인에서 너무 많은 처리를 해버리면 후속 시스템들이 파이프라인에 종속적이게 됩니다.</p><p>가령 어떤 필드를 보존하고, 데이터 집계를 어떻게 할 지에 대한 요구사항이 있을 때 파이프라인의 처리 로직을 변경해야하기 때문에 신속성, 효율성, 안전성이 떨어지게 됩니다.</p><p>그러니 가능한 원시 데이터의 형태로 보존하는 편이 좋고, 후속 애플리케이션에서 스스로 결정하여 데이터 처리를 하는 편이 더 나은 방법입니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="카프카-커넥트-vs-프로듀서컨슈머"></a>카프카 커넥트 VS 프로듀서/컨슈머<a class="hash-link" href="#카프카-커넥트-vs-프로듀서컨슈머" title="Direct link to heading">#</a></h2><ul><li><p>둘 중 언제 어느 것을 사용하는 편이 좋을까?</p></li><li><p>코드를 작성할 수 없고 변경도 불가능한 시스템들 ( DB, Storage Service, Amazon S3, 하둡 HDFS, ES )에 카프카를 연결할 때 <strong>카프카 커넥트</strong>를 사용한다.</p></li><li><p>카프카의 데이터를 일거엇 외부 시스템에 쓰는데 사용하는 컴포넌트 클래스가 <strong>커넥터</strong></p></li></ul><img width="652" alt="스크린샷 2021-06-05 오후 9 19 46" src="https://user-images.githubusercontent.com/43809168/120891464-c3803580-c643-11eb-9770-d48bea81d4e9.png"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="카프카-커넥트"></a>카프카 커넥트<a class="hash-link" href="#카프카-커넥트" title="Direct link to heading">#</a></h2><ul><li>카프카 커넥트는 아파치 카프카의 일부로 포함되며 카프카와 다른 데이터 저장소간의 데이터 이동을 위해 확장성과 신뢰성 있는 방법을 제공한다.</li></ul><img width="888" alt="스크린샷 2021-06-05 오후 8 24 39" src="https://user-images.githubusercontent.com/43809168/120890202-0e964a80-c63c-11eb-9362-48db79845ca6.png"><ul><li><p>카프카 커넥터는 <strong>Source</strong> 커넥터와 <strong>Sink</strong> 커넥터 두 종류로 나눠진다.</p></li><li><p>소스 커넥터 : 외부 시스템 -&gt; 커넥트 -&gt; 카프카</p></li><li><p>싱크 커넥터 : 카프카 -&gt; 커넥트 -&gt; 외부 시스템</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커넥트의-내부구조"></a>커넥트의 내부구조<a class="hash-link" href="#커넥트의-내부구조" title="Direct link to heading">#</a></h2><img width="813" alt="스크린샷 2021-06-05 오후 8 31 00" src="https://user-images.githubusercontent.com/43809168/120890329-f1ae4700-c63c-11eb-9e9f-da549304ef28.png"><p>커넥트는 미리 템플릿이 구현되어있고 그 템플릿의 설정값을 기준으로 인스턴스를 생성합니다.</p><p>커넥트에서는 그 템플릿을 <strong>Plugin</strong>이라 부릅니다.</p><p>이제부터 하나씩 자세히 그 역할을 들여다보도록 하겠습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커넥터"></a>커넥터<a class="hash-link" href="#커넥터" title="Direct link to heading">#</a></h3><p>커넥터는 파이프라인의 Task들을 관리합니다.</p><p>예를 들어, JDBC 소스 커넥터는 DB에 연결하고 복사할 기존 테이블들을 찾은 후 그 결과에 기반해 몇 개의 테스크가 필요한지를 결정합니다.</p><p>REST API를 사용해서 커넥터를 실행할 때는 어떤 노드에서도 시작시킬 수 있고, 이후 실행되는 테스크들도 마찬가지로 REST API로 실행시킬 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="태스크"></a>태스크<a class="hash-link" href="#태스크" title="Direct link to heading">#</a></h3><p>태스크는 카프카의 데이터를 실제로 입출력하는 책임을 갖습니다.</p><p>모든 태스크는 관련 워커 프로세스로부터 <strong>컨텍스트</strong>를 받아 초기화됩니다.</p><p>예를 들어, 소스 컨텍스트는 하나의 객체를 포함하며 이 객체는 소스 태스크가 소스 레코드의 오프셋을 저장할 수 있게 해줍니다.</p><p>즉 태스크는 카프카와의 메시지 복제에 대한 구현체이고 실제 파이프라인의 동작 요소들입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="워커-프로세스"></a>워커 프로세스<a class="hash-link" href="#워커-프로세스" title="Direct link to heading">#</a></h3><p>카프카 커넥트의 워커 프로세스는 커넥터와 태스크를 실행하는 <strong>컨테이너</strong> 프로세스입니다.</p><p>커넥터와 커넥터의 구성을 정의하는 HTTP 요청을 처리하는 책임을 갖습니다.</p><p>워커 프로세스는 커넥트의 구성을 저장하고 커넥터와 해당 커넥터의 태스크를 실행시킵니다.</p><p>만약 특정 워커 프로세스가 중지되면 커넥트 클러스터의 다른 워커 프로세스들이 이를 알게 되고, 중단된 워커 프로세스에서 실행되던 커넥터와 태스크들이 나머지 워커 프로세스들에게 재할당됩니다.</p><p>새로운 워커 프로세스가 커넥트 클러스터에 합류하면, 다른 워커 프로세스들이 이를 알게 되고, 모든 워커 프로세스의 워커량이 균등하게 조정되도록 새로 합류한 워커 프로세스에게 커넥터와 태스크가 할당됩니다.</p><p>워커 프로세스는 소스와 싱크 커넥터 모두의 오프셋을 자동으로 커밋하고 에러가 생길 때 재시도를 수행합니다.</p><p>커넥터와 태스크는 데이터 통합에서 <strong>이동되는 데이터</strong>만을 처리한다면,</p><p>워커 프로세스는 REST API, 구성 관리, 신뢰성, 고가용성, 확장성, 부하 분산 등의 모든 작업을 처리하는 책임을 갖습니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커넥터를-고려할-때-주의할-점"></a>커넥터를 고려할 때 주의할 점<a class="hash-link" href="#커넥터를-고려할-때-주의할-점" title="Direct link to heading">#</a></h2><p>커넥터를 구성할 때 몇 가지 주의해야할 점이 있습니다.</p><ul><li><p>외부 시스템을 지원하는 플러그인의 존재 유무</p></li><li><p>해당 플러그인의 라이센스 정보</p></li></ul><p>플러그인의 경우 제공하는 업체나 커뮤니티가 각각 다릅니다. (심지어 싱크와 소스도 따로 제공되는 경우도 많다고 합니다)</p><p>그렇기 때문에 커넥터를 고려할 때는 라이센스도 같이 확인을 해봐야합니다.</p><p>JDBC Connector의 경우 Source와 Sink를 모두 지원하고 무료입니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="카프카-커넥트의-대안"></a>카프카 커넥트의 대안<a class="hash-link" href="#카프카-커넥트의-대안" title="Direct link to heading">#</a></h2><p>지금까지 카프카 커넥트 API에 관해 깊게 공부해보았습니다.</p><p>카프카 커넥트 API는 얼핏 좋아보이지만, 라이센스 이슈로 인해 사용하지 못할 수도 있습니다.</p><p>이런 경우 대안은 어떤 것들이 있을까요?</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다른-데이터스토어의-프레임워크"></a>다른 데이터스토어의 프레임워크<a class="hash-link" href="#다른-데이터스토어의-프레임워크" title="Direct link to heading">#</a></h3><p>카프카가 우주의 중심이라고 생각하는 사람도 있지만, 이에 동의하지 않는 사람들도 있습니다.</p><p>하둡이나 ES로 대부분의 데이터 아키텍처를 구축하는 사람들도 있기 때문이지요.</p><p>이러한 시스템들은 대체로 데이터 처리에 필요한 수집, 통합, 전달 도구를 갖고 있습니다.</p><p>가령 하둡의 경우 Flume, ES는 로그스태시와 플루언트디가 있죠.</p><p>카프카가 아키텍처의 핵심 부분이고 대량의 소스와 싱크를 연결하는 것이 그 목적이라면 카프카 커넥트 API는 필수적인 선택입니다.</p><p>그러나 하둡이나 ES가 중심의 시스템이라면 카프카는 그 시스템의 입력 시스템 중 하나로 고려하고, 플룹이나 로그스태시 플루언트디를 사용합시다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스트림-프로세싱-프레임워크"></a>스트림 프로세싱 프레임워크<a class="hash-link" href="#스트림-프로세싱-프레임워크" title="Direct link to heading">#</a></h2><blockquote><p>이 부분은 개인적으로 이해가 잘 안갔습니다. 스트림 프로세싱 프레임워크가 무엇이고, 데이터 통합을 같은 프레임워크로 한다는게 무슨 의미일까요</p></blockquote><p>대부분의 스트림 프로세싱 프레임워크에서는 카프카로부터 데이터를 읽어 다른 대상 시스템에 쓸 수 있습니다.</p><p>대상 시스템이 카프카를 지원하고, 카프카의 데이터 처리를 위해 스트림 프로세싱 프레임워크를 사용할 의향이 있다면, 데이터 통합도 같은 프레임워크를 사용하는 편이 바람직할 것 같습니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론"></a>결론<a class="hash-link" href="#결론" title="Direct link to heading">#</a></h2><p>카프카 커넥터 API이 왜 데이터 통합에 적합한지에 대하여 알아보았습니다. (내부 동작도)</p><p>최종적으로 어떤 데이터 통합 솔루션을 사용하든, 모든 장애 상황에서 모든 데이터를 전달할 수 있는 능력이 가장 중요할 듯 한데요.</p><p>그런 면에서 저자는 카프카 커넥트가 매우 신뢰성이 높다고 믿고 있습니다.</p><p>그러나 궁극적으로 데이터 통합 시스템의 목적은 데이터를 전달하는 것이므로 카프카 커넥트를 사용하지 않더라도 충분한 테스트를 통해 데이터 전송 신뢰성을 확보한다면 다른 대안을 사용하는 것도 좋다고 말하고 있습니다.</p><p>결국 시스템 요구사항에 맞게 적절하게 사용할 수 있도록 하는 것이 가장 중요할 듯 싶습니다.</p><p>마지막으로 객체지향의 바이블이라 불리는 조영호님의 책 <code>Object</code>의 마지막 구절로 마무리하도록 하겠습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">소프트웨어 개발에서 모든 설계는 Trade-Off의 산물이다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">By 조영호</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reference"></a>Reference<a class="hash-link" href="#reference" title="Direct link to heading">#</a></h2><img width="458" alt="스크린샷 2021-04-28 오후 7 39 45" src="https://user-images.githubusercontent.com/43809168/116390936-86ad6b80-a859-11eb-91e8-fcfc31a896fe.png"><p>카프카 핵심 가이드</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/minkukjo/study/edit/master/docs/kafka/kafka-core-guide/07-data-pipeline.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-22T06:01:36.000Z" class="lastUpdatedDate_1WI_">7/22/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/study/docs/kafka/kafka-core-guide/05-internal"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 05. 카프카의 내부 메커니즘</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/study/docs/kafka/kafka-core-guide/11-streams"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">11. 스트림 프로세싱 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#데이터-파이프라인이란" class="table-of-contents__link">데이터 파이프라인이란</a></li><li><a href="#데이터-파이프라인-구축-시-고려사항" class="table-of-contents__link">데이터 파이프라인 구축 시 고려사항</a><ul><li><a href="#적시성" class="table-of-contents__link">적시성</a></li><li><a href="#신뢰성" class="table-of-contents__link">신뢰성</a></li><li><a href="#높으면서도-조정-가능한-처리량" class="table-of-contents__link">높으면서도 조정 가능한 처리량</a></li><li><a href="#데이터-형식" class="table-of-contents__link">데이터 형식</a></li><li><a href="#변환" class="table-of-contents__link">변환</a></li><li><a href="#보안" class="table-of-contents__link">보안</a></li><li><a href="#장애-처리" class="table-of-contents__link">장애 처리</a></li><li><a href="#결합과-민첩성" class="table-of-contents__link">결합과 민첩성</a></li></ul></li><li><a href="#카프카-커넥트-vs-프로듀서컨슈머" class="table-of-contents__link">카프카 커넥트 VS 프로듀서/컨슈머</a></li><li><a href="#카프카-커넥트" class="table-of-contents__link">카프카 커넥트</a></li><li><a href="#커넥트의-내부구조" class="table-of-contents__link">커넥트의 내부구조</a><ul><li><a href="#커넥터" class="table-of-contents__link">커넥터</a></li><li><a href="#태스크" class="table-of-contents__link">태스크</a></li><li><a href="#워커-프로세스" class="table-of-contents__link">워커 프로세스</a></li></ul></li><li><a href="#커넥터를-고려할-때-주의할-점" class="table-of-contents__link">커넥터를 고려할 때 주의할 점</a></li><li><a href="#카프카-커넥트의-대안" class="table-of-contents__link">카프카 커넥트의 대안</a><ul><li><a href="#다른-데이터스토어의-프레임워크" class="table-of-contents__link">다른 데이터스토어의 프레임워크</a></li></ul></li><li><a href="#스트림-프로세싱-프레임워크" class="table-of-contents__link">스트림 프로세싱 프레임워크</a></li><li><a href="#결론" class="table-of-contents__link">결론</a></li><li><a href="#reference" class="table-of-contents__link">Reference</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Harry's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/study/assets/js/runtime~main.24c4b89c.js"></script>
<script src="/study/assets/js/main.d36122be.js"></script>
</body>
</html>